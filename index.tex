% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={XIAO: Big Power, Small Board},
  pdfauthor={Lei Feng, Marcelo Rovai},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{XIAO: Big Power, Small Board}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Mastering Arduino and TinyML}
\author{Lei Feng, Marcelo Rovai}
\date{2023-12-08}

\begin{document}
\maketitle
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[sharp corners, interior hidden, borderline west={3pt}{0pt}{shadecolor}, frame hidden, enhanced, breakable, boxrule=0pt]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

From the expansive boards of the past, Arduino has come a long way and
entered the Seeed Studio XIAO series: thumb-sized yet power-packed,
opening a vast horizon for innovation. ``XIAO: Big Power, Small Board''
dives deep into these capabilities, guiding readers from the basics of
Arduino to intricate miniaturized projects. Whether readers want to
illuminate an LED or delve into Embedded Machine Learning (TinyML) with
XIAO boards and Edge Impulse Studio, this book covers them. Need for
prior knowledge? No worries! This book takes a hands-on, project-based
approach, ensuring readers grasp the concepts while implementing them.
By the end, they will be adept with XIAO and inspired by many
user-created projects showcasing the endless possibilities this small
board offers.

\bookmarksetup{startatroot}

\hypertarget{acknowledgments}{%
\chapter*{Acknowledgments}\label{acknowledgments}}
\addcontentsline{toc}{chapter}{Acknowledgments}

\markboth{Acknowledgments}{Acknowledgments}

We want to express our sincere gratitude to Jiamou Yang, Yanming Wen,
Mengdu Li, Chunchun Tian, Haixu Liu, Tianrui Wang, and Jianjing Huang
for their invaluable technical support and manuscript revisions. This
book would not have been possible without their contributions.

We extend our deepest gratitude to the entire TinyML4D Academic Network,
comprised of distinguished professors, researchers, and professionals.
Notable contributions from Marco Zennaro, Brian Plancher, Jos√© Alberto
Ferreira, Jesus Lopez, Diego Mendez, Shawn Hymel, Dan Situnayake, Pete
Warden, and Laurence Moroney have been instrumental in advancing our
understanding of Embedded Machine Learning (TinyML).

Special commendation is reserved for Professor Vijay Janapa Reddi of
Harvard University. His steadfast belief in the transformative potential
of open-source communities, coupled with his invaluable guidance and
teachings, has served as a beacon for our efforts from the very
beginning.

Acknowledging these individuals, we pay tribute to the collective wisdom
and dedication that have enriched this field and our work.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Illustrative images on the e-book and chapter's covers generated by
OpenAI's DALL-E via ChatGPT

\bookmarksetup{startatroot}

\hypertarget{introduction}{%
\chapter*{Introduction}\label{introduction}}
\addcontentsline{toc}{chapter}{Introduction}

\markboth{Introduction}{Introduction}

The Seeed Studio XIAO series represents a groundbreaking evolution in
the Arduino ecosystem, merging compactness with powerful performance.
Understanding and harnessing its capabilities are essential for any
enthusiast or professional in electronics and machine learning. With the
rapid progression of technology and the increasing demand for smaller,
more efficient devices, mastering XIAO and its integration with TinyML
is crucial. It presents a new frontier for innovation, allowing the
creation of sophisticated projects in spaces previously thought
impossible. This topic is paramount as it aligns with the future
trajectory of electronics, IoT, and machine learning, making it
indispensable for those aiming to stay at the forefront of technological
advancements.

\bookmarksetup{startatroot}

\hypertarget{about-this-book}{%
\chapter*{About this Book}\label{about-this-book}}
\addcontentsline{toc}{chapter}{About this Book}

\markboth{About this Book}{About this Book}

\hypertarget{audience}{%
\section*{Audience}\label{audience}}
\addcontentsline{toc}{section}{Audience}

\markright{Audience}

The primary audience for ``XIAO: Big Power, Small Board'' encompasses
hobbyists, students, educators, and professionals in electronics and
machine learning who want to explore and maximize the potential of
compact hardware platforms. Typically, these readers might hold
positions as electronics enthusiasts, DIY project creators, electronics
educators, or even junior embedded system developers. As they advance in
their careers, they might be eyeing roles such as electronics design
engineers, IoT developers, or machine learning hardware integrators.

Our audience possesses a basic understanding of electronics concepts but
may have yet to delve deep into Arduino programming or compact hardware
design. They likely have encountered standard beginner books on Arduino
or general electronics but might have yet to venture into specialized
hardware or TinyML. As for skills, they have some hands-on experience
with basic electronics or programming but haven't mastered the
intricacies of TinyML or advanced microcontroller functionalities.

\hypertarget{what-readers-will-learn}{%
\section*{What readers will learn}\label{what-readers-will-learn}}
\addcontentsline{toc}{section}{What readers will learn}

\markright{What readers will learn}

By the end of this book, the reader will understand:

\begin{itemize}
\item
  The fundamentals of open-source hardware, focusing on the capabilities
  of the Seeed Studio XIAO series.
\item
  How to transition from basic to advanced electronic projects, starting
  with simple LED controls and advancing to complex applications like
  telemetry and voice keyword detection.
\item
  The concepts behind prototype design and its practical implications in
  product development.
\item
  The intricacies of integrating various modules like the infrared
  receiver, ultrasonic distance sensor, and RTC clock with the XIAO
  platform.
\item
  The significance and application of Tiny Machine Learning (TinyML),
  emphasizing its transformative power in hardware like the XIAO
  nRF52840 Sense and ESP32S3 Sense.
\item
  Techniques to utilize advanced tools such as Edge Impulse Studio for
  real-world applications like anomaly and object detection and video or
  sound classification.
\end{itemize}

The reader will be able to:

\begin{itemize}
\item
  Set up, program, and troubleshoot projects across all XIAO series
  boards, advancing from basic hardware interactions to intricate
  project designs.
\item
  Convert abstract ideas into tangible electronic product prototypes,
  leveraging the insights from the course.
\item
  Design and implement intermediate-level projects such as a Smart Watch
  and Air Piano using specialized sensors and modules.
\item
  Harness the power of Wi-Fi and MQTT protocols with XIAO ESP32C3 for
  cloud communications and data exchange.
\item
  Deploy TinyML on different XIAO boards, executing tasks like image,
  motion, and sound classification besides anomaly and object detection.
\item
  Innovate and extend project ideas, drawing inspiration from a curated
  collection of XIAO projects and adapting them for custom needs.
\end{itemize}

\hypertarget{software-dependencies}{%
\section*{Software dependencies}\label{software-dependencies}}
\addcontentsline{toc}{section}{Software dependencies}

\markright{Software dependencies}

\begin{itemize}
\item
  \textbf{Arduino IDE}: Major updates or changes to the Arduino IDE
  might affect content related to Arduino development and programming in
  the book.
\item
  \textbf{Seeed Studio XIAO Libraries}: Updates to libraries specific to
  the XIAO series can influence the projects or example codes provided.
\item
  \textbf{Edge Impulse Studio}: Significant updates or feature changes
  on this platform would necessitate adjustments in the TinyML chapters.
\item
  \textbf{MQTT Libraries/Protocols}: Any changes related to MQTT
  libraries or the protocol itself could influence the content of
  telemetry and commands.
\item
  \textbf{ESP32 Libraries}: Updates to libraries used by the XIAO
  ESP32C3 and ESP32S3 board may impact associated projects or examples.
\end{itemize}

\hypertarget{book-outline}{%
\section*{Book outline}\label{book-outline}}
\addcontentsline{toc}{section}{Book outline}

\markright{Book outline}

\begin{itemize}
\item
  \textbf{Chapter 1: Introduction to Hardware and Programming} In this
  chapter, readers start with basic programming on XIAO using Arduino
  IDE. Through simple example programs, they will learn to control LED
  lights, buttons, buzzers, and other electronic components, mastering
  core programming concepts like digital I/O, analog I/O, tone
  generation, and mapping values. By manually typing out code examples
  line-by-line, they will develop strong coding habits and grasp
  programming syntax.
\item
  \textbf{Chapter 2: Project Practice for Beginners - Introduction to
  Prototype Design} In this chapter, readers will learn the basics of
  designing prototypes with XIAO through beginner-friendly projects.
  They will start from an idea and quickly create a verification
  prototype, focusing more on the practical application of code rather
  than line-by-line analysis. By leveraging Arduino libraries, community
  resources, and example programs, they will learn how to find and adapt
  code snippets to achieve desired effects efficiently. Furthermore,
  they will explore how to design the physical appearance of prototypes
  by creatively combining electronic hardware with everyday items. The
  key outcomes are grasping a project-based approach and developing
  skills to build simple interactive prototypes.
\item
  \textbf{Chapter 3: Intermediate Project Practice---Complex Projects}
  In this chapter, readers will advance their prototyping skills by
  creating sophisticated IoT projects with XIAO. They will implement
  features like Wi-Fi connectivity, MQTT telemetry, and remote control
  commands using the XIAO ESP32C3. Through complex builds like an
  intelligent remote door, smartwatch, and air piano, you will hone
  programming techniques for wireless communication, cloud integration,
  and embedded control. Optional blueprints will be provided, but
  readers are encouraged to explore creative enclosure designs with
  alternative materials. The key outcomes are mastering intermediate IoT
  prototyping and preparing for advanced tinyML applications.
\item
  \textbf{Chapter 4: Project Practice Advanced - tinyML Application}
  Among the XIAO series products, the Seeed Studio XIAO nRF52840 Sense
  has Bluetooth 5.0 wireless connectivity, low power consumption, and
  comes with onboard 6-axis IMU and PDM microphone sensors. The XIAO
  ESP32S3 Sense further integrates a camera, digital microphone, and SD
  card support. Those features make them powerful tools for TinyML
  (Embedded Machine Learning) projects. TinyML solves problems in a
  completely different way from traditional programming methods. This
  chapter will introduce readers to this cutting-edge field by walking
  through the entire machine-learning workflow from data collection,
  training, and testing to deployment and inference using the Edge
  Impulse Studio tool.
\item
  \textbf{Chapter 5: Creative Experiments} Since its launch, the Seeed
  Studio XIAO series has been widely acclaimed for its compact size,
  powerful performance, and versatile product range. The maker community
  has produced a large number of projects created with XIAO. Due to
  space constraints, we have selected some outstanding projects made
  with XIAO by our makers. These projects fully demonstrate the powerful
  functions and wide applications of XIAO. Let us follow the makers'
  steps, stimulate creativity, and explore the endless possibilities of
  XIAO. Readers can draw inspiration from these projects, use
  imagination, and explore new territories with XIAO.
\end{itemize}

\bookmarksetup{startatroot}

\hypertarget{introduction-to-hardware-and-programming}{%
\chapter{Introduction to Hardware and
Programming}\label{introduction-to-hardware-and-programming}}

In this unit, we will enter the world of electronics and programming and
explore how to control hardware through code. Starting with the example
program, Blink, we will learn how to light up an LED, turn the light on
and off through a button, control the sound of a passive buzzer, and so
on. In each task, we will master commonly used programming languages,
such as digital input/output, analog input/output, tone and map
functions, etc., and learn the primary usage of libraries. The programs
in this unit are relatively simple. During the learning process, write
the program code for each task by hand, develop good habits, and avoid
program upload failures due to errors in symbols or unfamiliar rules.

\bookmarksetup{startatroot}

\hypertarget{first-arduino-program-with-seeed-studio-xiao-blink}{%
\chapter*{1.1 First Arduino program with Seeed Studio XIAO:
Blink}\label{first-arduino-program-with-seeed-studio-xiao-blink}}
\addcontentsline{toc}{chapter}{1.1 First Arduino program with Seeed
Studio XIAO: Blink}

\markboth{1.1 First Arduino program with Seeed Studio XIAO: Blink}{1.1
First Arduino program with Seeed Studio XIAO: Blink}

Arduino is a globally popular open-source electronic prototyping
platform, including various models of Arduino development boards and the
Arduino IDE software platform. Because of its open, convenient, and
easy-to-start characteristics, it has become the first choice for many
software and hardware beginners. With it, you can quickly complete
project development and implement your own ideas. To date, Arduino has
introduced a variety of different models of controllers and numerous
peripheral modules, such as various sensors, actuators, expansion
boards, etc. These modules, when used with Arduino, can implement a
variety of interesting and practical projects. The Seeed Studio XIAO
series products we are learning about today are development boards
derived from Arduino. They belong to the Seeeduino series and are the
smallest members of this series. \#\# 1.1.1 Arduino IDE Text Editor We
need to program the hardware through the Arduino IDE text editor. If you
have not installed the Arduino IDE, you can go to the download page to
install it: üîó \href{https://www.arduino.cc/en/software}{Software}.
Simply put, the Arduino IDE (Integrated Development Environment) is a
programming software specifically designed for Arduino. Through it, we
can write and upload different programs for Arduino hardware. When we
open the Arduino IDE software, it will create a new file named sketch,
of course, we can rename it. \#\#\#\# For Windows Users The interface of
the Arduino IDE is very clean, and can be divided into four parts: menu
bar, toolbar, editing area, and debug window.
\includegraphics{index_files/mediabag/1684140531171-ced7db.jpeg}

\includegraphics{index_files/mediabag/1669014289466-69df6f.png-averageHue=-938834-clientId=u1e0121}Menu
bar: Includes files, edit, sketch, tools, and help, such as new, save,
example programs, select serial port, etc.
\includegraphics{index_files/mediabag/1669014346076-85c627.png-averageHue=-918633-clientId=u1e0121}
Horizontal toolbar: Contains several commonly used function buttons:
verify, upload, debug, board selection, serial plotter, and serial
monitor selection.
\includegraphics{index_files/mediabag/1669014391728-2a5bec.png-averageHue=-918533-clientId=u1e0121}Vertical
toolbar: Contains shortcuts to the project folder, board manager,
library manager, debug, and search.
\includegraphics{index_files/mediabag/1669017211350-66d61f.png-averageHue=-918533-clientId=uc9acbb}
Code editing area: This is where you write program code, just as we
usually type text in a Word window, write the program code in this area.
\includegraphics{index_files/mediabag/1669017227268-8d3619.png-averageHue=-918533-clientId=uc9acbb}Serial
monitor, output window: On the right side of the horizontal toolbar, you
can open or close the serial monitor window. \#\#\#\# For MAC Users
Except for the location of the menu bar (at the top), which is slightly
different from Windows users, all other tools and experiences are
basically the same.
\includegraphics{index_files/mediabag/1684139774017-9637ff.jpeg}

\hypertarget{adding-seeed-studio-xiao-to-arduino-ide}{%
\section*{1.1.2 Adding Seeed Studio XIAO to Arduino
IDE}\label{adding-seeed-studio-xiao-to-arduino-ide}}
\addcontentsline{toc}{section}{1.1.2 Adding Seeed Studio XIAO to Arduino
IDE}

\markright{1.1.2 Adding Seeed Studio XIAO to Arduino IDE}

\begin{quote}
\hypertarget{attention}{%
\subsection*{‚ö†Ô∏è Attention}\label{attention}}
\addcontentsline{toc}{subsection}{‚ö†Ô∏è Attention}

Due to space limitations, all parts about program code and hardware
connection in this course are based on Seeed Studio
\href{https://www.seeedstudio.com/Seeeduino-XIAO-Arduino-Microcontroller-SAMD21-Cortex-M0+-p-4426.html}{XIAO
SAMD21}. Most of the code in the course can be applied to all products
in the Seeed Studio XIAO series. If there are exceptions, they will be
additionally marked or explained for applicable hardware. If not marked,
they are applicable to multiple products.
\end{quote}

We need to add the Seeed Studio XIAO series products to the Arduino IDE
to start our learning journey.

\begin{itemize}
\tightlist
\item
  For Windows users, first open your Arduino IDE, click on
  ``File‚ÜíPreferences'' in the top menu bar, as shown in the figure, and
  copy the following URL into ``Additional Boards Manager URLs''.
\item
  For Mac users, first open your Arduino IDE, click on ``Arduino
  IDE‚ÜíPreferences'' in the top menu bar, as shown in the figure, and
  copy the following URL into ``Additional Boards Manager URLs''.
\item
  For Seeed Studio XIAO SAMD21, XIAO nRF52840, and XIAO nRF52840 Sense,
  copy the link address below:
  \url{https://files.seeedstudio.com/arduino/package_seeeduino_boards_index.json}
\item
  For Seeed Studio XIAO RP2040, copy the link address below:
  \url{https://github.com/earlephilhower/arduino-pico/releases/download/global/package_rp2040_index.json}
\item
  For Seeed Studio XIAO ESP32C3, XIAO ESP32S3, copy the link address
  below:
  \url{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json}
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/1684140735129-effa8a.jpeg}

}

\end{figure}

If you frequently use multiple different models of XIAO at the same
time, you can click on the
\includegraphics{.pdf}\includegraphics[width=10mm,height=6mm]{images/chapter_1/icon.jpg}icon
on the right side of the address bar and add all three addresses above
to the board manager, as shown in the figure below.
\includegraphics{index_files/mediabag/1684140807895-8ef9ff.png-averageHue=-c6c9c9-clientId=u86b65a}
Next, click on ``Tools‚ÜíBoard‚ÜíBoard Manager'', enter the keyword
\texttt{Seeeduino\ XIAO} in the search bar, find
\texttt{Seeed\ SAMD\ Boards} in the appeared entries, and click
\texttt{INSTALL}.
\includegraphics{index_files/mediabag/1684142355010-1f3351.jpeg} When
the installation starts, you will see an output pop-up window. After the
installation is complete, an ``INSTALLED'' option will appear.

\begin{quote}
‚ö†Ô∏è Attention

\begin{itemize}
\tightlist
\item
  Enter ``RP2040'' in the search bar to find the installation package
  for Seeed XIAO RP2040.
\item
  Enter ``XIAO nrf52840'' to find two installation packages: Seeed nRF52
  Boards (for low-power projects) and Seeed nRF52 mbed-enabled Boards
  (for higher power TinyML projects).
\item
  Enter ``ESP32'' to find the installation package for esp32 by
  Espressif Systems.
\end{itemize}
\end{quote}

\hypertarget{connecting-seeed-studio-xiao-to-arduino-ide}{%
\subsection*{Connecting Seeed Studio XIAO to Arduino
IDE}\label{connecting-seeed-studio-xiao-to-arduino-ide}}
\addcontentsline{toc}{subsection}{Connecting Seeed Studio XIAO to
Arduino IDE}

Connect XIAO to the computer with a data cable, as shown in the figure
below:
\includegraphics{index_files/mediabag/1615797195994-1d6944.png-averageHue=-efefee-height=962-id=ac}
Next, click on ``Tools‚ÜíBoard'', find ``Seeeduino XIAO'' and select it,
as shown in the figure below.
\includegraphics{index_files/mediabag/1684142575447-8cf375.png-averageHue=-89b575-clientId=u86b65a}

\begin{quote}
‚ö†Ô∏è Attention If your development board is XIAO nRF52840, please select
Seeed XIAO nrf52840. If your development board is XIAO nRF52840 Sense,
please select Seeed XIAO nrf52840 Sense. If your development board is
XIAO RP2040, please select Seeed XIAO RP2040. If your development board
is XIAO ESP32C3, please select XIAO\_ESP32C3. If your development board
is XIAO ESP32S3, please select XIAO\_ESP32S3.
\end{quote}

Check if the port connection is correct, if not, you need to select it
manually.

\begin{itemize}
\tightlist
\item
  The serial port on Windows systems is displayed as ``COM+number'', as
  shown in the figure below.
\item
  On Mac or Linux systems, the serial port name is generally
  /dev/tty.usbmodem+number or /dev/cu.usbmodem+number, as shown in the
  figure below.
\end{itemize}

Now, we can start programming XIAO through the software.

\begin{quote}
\hypertarget{xiao-esp32c3-may-not-be-recognized-properly-in-arduino-ide-2-you-need-to-manually-specify-the-development-board-and-port.}{%
\subsubsection*{‚ö†Ô∏è XIAO ESP32C3 may not be recognized properly in
Arduino IDE 2, you need to manually specify the development board and
port.}\label{xiao-esp32c3-may-not-be-recognized-properly-in-arduino-ide-2-you-need-to-manually-specify-the-development-board-and-port.}}
\addcontentsline{toc}{subsubsection}{‚ö†Ô∏è XIAO ESP32C3 may not be
recognized properly in Arduino IDE 2, you need to manually specify the
development board and port.}
\end{quote}

\includegraphics{index_files/mediabag/1684219110243-6ef7e0.jpeg}
\textgreater{} When ESP32C3 is plugged into a PC with Arduino IDE 2, it
may not be able to automatically match the correct development board. As
shown in the figure below, the display is not XIAO ESP32 development
board, you need to manually specify. Choose ``Select Other Board \&
Port\ldots{}'' from the Port drop-down menu. Enter ``xiao'' in the
search bar of the development board, select the XIAO\_ESP32C3
development board from the filtered list below, and confirm after
selecting the port on the right.

\includegraphics{index_files/mediabag/1684219312231-9d33ce.jpeg}
\textgreater{} Now you can see that the development board and port are
in the correct state. \textgreater{}
\includegraphics{index_files/mediabag/1684219357868-bd5018.png-averageHue=-e8b64e-clientId=u112af1}

\begin{quote}
\hypertarget{reset-seeed-studio-xiao}{%
\subsection*{‚ö†Ô∏è Reset Seeed Studio XIAO}\label{reset-seeed-studio-xiao}}
\addcontentsline{toc}{subsection}{‚ö†Ô∏è Reset Seeed Studio XIAO}

Sometimes when the program upload fails, the Seeed Studio XIAO port may
disappear, and we need to perform a reset operation. The reset method
will be different for different models of XIAO.

\hypertarget{reset-of-seeed-studio-xiao-samd21}{%
\subsubsection*{Reset of Seeed Studio XIAO
SAMD21}\label{reset-of-seeed-studio-xiao-samd21}}
\addcontentsline{toc}{subsubsection}{Reset of Seeed Studio XIAO SAMD21}

\begin{itemize}
\tightlist
\item
  Connect XIAO SAMD21 to your computer.
\item
  Open ``Blink'' in the Arduino IDE sample program and click upload.
\item
  While uploading, short circuit the RST pin in the figure once with
  tweezers or a short wire.
\item
  The reset is completed when the orange LED flashes and lights up.
\end{itemize}
\end{quote}

As shown in the figure below.
\includegraphics{index_files/mediabag/1684219420537-9556aa.gif-averageHue=-47918c-clientId=u112af1}
\textgreater{} Reset of Seeed Studio XIAO PR2040 \textgreater{} -
Connect Seeed Studio XIAO RP2040 to your computer. \textgreater{} -
Press the reset button marked with ``R'' once, the position is shown in
the figure below.

\includegraphics{index_files/mediabag/1684219597756-6dbd99.jpeg} If this
does not work, hold down the Boot button marked with ``B'', connect the
board to your computer while holding down the BOOT button, and then
release it to enter the bootloader mode. \textgreater{} \#\#\#\# Reset
of Seeed Studio XIAO nRF52840 and Sense version \textgreater{} - Connect
Seeed Studio XIAO nRF52840 or Sense version to your computer.
\textgreater{} - Press the reset button marked with ``RST'' once, the
position is shown in the figure below.

\includegraphics{index_files/mediabag/1684219636704-506e4c.jpeg} If this
does not work, you can quickly click it twice to enter the bootloader
mode.

\begin{quote}
\hypertarget{reset-of-seeed-studio-xiao-esp32c3}{%
\subsubsection*{Reset of Seeed Studio XIAO
ESP32C3}\label{reset-of-seeed-studio-xiao-esp32c3}}
\addcontentsline{toc}{subsubsection}{Reset of Seeed Studio XIAO ESP32C3}

\begin{itemize}
\tightlist
\item
  Connect Seeed Studio XIAO ESP32C3 to your computer.
\item
  Press the reset button marked with ``R'' once, the position is shown
  in the figure below.
\end{itemize}
\end{quote}

\includegraphics{index_files/mediabag/1684224461683-7ba8c1.jpeg} If this
does not work, hold down the Boot button marked with ``B'', connect the
board to your computer while holding down the BOOT button, and then
release it to enter the bootloader mode.

\begin{quote}
\hypertarget{reset-of-seeed-studio-xiao-esp32s3}{%
\subsubsection*{Reset of Seeed Studio XIAO
ESP32S3}\label{reset-of-seeed-studio-xiao-esp32s3}}
\addcontentsline{toc}{subsubsection}{Reset of Seeed Studio XIAO ESP32S3}

\begin{itemize}
\tightlist
\item
  Connect Seeed Studio XIAO ESP32S3 to your computer.
\item
  Press the reset button marked with ``R'' once, the position is shown
  in the figure below.
\end{itemize}
\end{quote}

\includegraphics{index_files/mediabag/1698388811596-f95d29.jpeg} If this
does not work, hold down the Boot button marked with ``B'', connect the
board to your computer while holding down the BOOT button, and then
release it to enter the bootloader mode.

\hypertarget{structure-of-arduino-programs}{%
\subsection*{Structure of Arduino
Programs}\label{structure-of-arduino-programs}}
\addcontentsline{toc}{subsection}{Structure of Arduino Programs}

Now that we have the development board, how can we write programs into
it to control its functions? That's when the Arduino IDE text editor
comes in handy. We've already introduced the interface functions of
Arduino IDE in the introduction, it's an important tool for writing and
uploading programs. Arduino programs consist of two basic functions:
\texttt{setup()} This function is called when the program begins. Use it
to initialize variables, pin modes, start using libraries, etc.
\texttt{setup()} runs only once each time the Arduino board is powered
on or reset.

\texttt{loop()} After the program in \texttt{setup()} is executed, the
program in \texttt{loop()} begins to execute. The program in
\texttt{loop()} runs repeatedly.
\includegraphics{index_files/mediabag/1684224618107-775f07.png-averageHue=-bd9641-clientId=u2787ef}
\textgreater{} Knowledge window: \textgreater{} - The contents after
``/* */'' and ``//'' are comments to help you understand and manage
code, the comments will not affect the normal operation of the program;
\textgreater{} - When writing programs, we need to use ``\{\}'' to wrap
a set of codes; \textgreater{} - After each line of code, use ``;'' as
an end symbol to tell the Arduino editor that this line of code
instruction is over.

\hypertarget{digital-signals-and-io-settings}{%
\subsection*{Digital Signals and I/O
Settings}\label{digital-signals-and-io-settings}}
\addcontentsline{toc}{subsection}{Digital Signals and I/O Settings}

Simply put, digital signals are signals represented in binary form of 0
and 1. In Arduino, digital signals are represented by high and low
levels, high level means digital signal 1, and low level means digital
signal 0. Seeed Studio XIAO has 11 digital pins, we can set these pins
to perform the function of inputting or outputting digital signals.
\includegraphics{index_files/mediabag/1684224782661-b9e9d1.jpeg} In
Arduino, you can use functions to set the status and function of pins.
Here are the basic steps to set pins through functions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  First, determine the pin number of the pin you want to control.
\item
  In the Arduino code, use the \texttt{pinMode()} function to set the
  function of the pin, such as input or output. For example, to set the
  pin to output mode, you can use the following code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ ledPin }\OperatorTok{=} \DecValTok{13}\OperatorTok{;} \CommentTok{// The pin to be controlled}
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ledPin}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);} \CommentTok{// Set the pin to output mode}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Once you have set the pin to output mode, you can use the
  \texttt{digitalWrite()} function to set the status of the pin, such as
  setting it to high or low level. For example, to set the pin to high
  level, you can use the following code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{digitalWrite}\OperatorTok{(}\NormalTok{ledPin}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);} \CommentTok{// Set the pin to high level}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  If you set the pin to input mode, you can use the
  \texttt{digitalRead()} function to read the status of the pin, such as
  detecting whether it is high or low level. For example, to read the
  status of the pin and save it to a variable, you can use the following
  code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// The pin to read the status from}
\DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// The variable to save the status}
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);} \CommentTok{// Set the pin to input mode}
\OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);} \CommentTok{// Read the status of the pin}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

By using functions like \texttt{pinMode()}, \texttt{digitalWrite()}, and
\texttt{digitalRead()}, you can easily set and control the status and
function of pins in Arduino. \#\# 1.1.3 Task 1: Run Blink to Make XIAO's
LED Flash Just as ``Hello World'' is the first section in all
programming languages, ``Blink'' is akin to ``Hello World'' in Arduino
programming. It is the key to our journey in learning Arduino. Arduino
provides many example codes to help us get started quickly, and Blink is
one of them. We can select ``File ‚Üí Examples ‚Üí 01.Basics ‚Üí Blink'' in
the Arduino window to open the example program Blink.
\includegraphics{index_files/mediabag/1684226229927-10eec1.png-averageHue=-83907e-clientId=u2787ef}
After opening the example program, you can see the following code, which
implements the effect of LED flashing. You can see that the code has
orange and green color prompts, which proves that your input is correct.
Pay attention to the difference between uppercase and lowercase.
\includegraphics{index_files/mediabag/1684226225853-975917.png-averageHue=-f6f6f6-clientId=u2787ef}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{  Blink}

\CommentTok{  Turns an LED on for one second, then off for one second, repeatedly.}

\CommentTok{  Most Arduinos have an on{-}board LED you can control. On the UNO, MEGA and ZERO}
\CommentTok{  it is attached to digital pin 13, on MKR1000 on pin 6. LED\_BUILTIN is set to}
\CommentTok{  the correct LED pin independent of which board is used.}
\CommentTok{  If you want to know what pin the on{-}board LED is connected to on your Arduino}
\CommentTok{  model, check the Technical Specs of your board at:}
\CommentTok{  https://www.arduino.cc/en/Main/Products}

\CommentTok{  modified 8 May 2014}
\CommentTok{  by Scott Fitzgerald}
\CommentTok{  modified 2 Sep 2016}
\CommentTok{  by Arturo Guadalupi}
\CommentTok{  modified 8 Sep 2016}
\CommentTok{  by Colby Newman}

\CommentTok{  This example code is in the public domain.}

\CommentTok{  https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink}
\CommentTok{*/}

\CommentTok{// the setup function runs once when you press reset or power the board}
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
  \CommentTok{// initialize digital pin LED\_BUILTIN as an output.}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// the loop function runs over and over again forever}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}  \CommentTok{// turn the LED on (HIGH is the voltage level)}
\NormalTok{  delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}                      \CommentTok{// wait for a second}
\NormalTok{  digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}   \CommentTok{// turn the LED off by making the voltage LOW}
\NormalTok{  delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}                      \CommentTok{// wait for a second}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{code-analysis}{%
\subsubsection*{Code Analysis}\label{code-analysis}}
\addcontentsline{toc}{subsubsection}{Code Analysis}

\hypertarget{pinmodeled_builtin-output}{%
\paragraph*{\texorpdfstring{\texttt{pinMode(LED\_BUILTIN,\ OUTPUT);}}{pinMode(LED\_BUILTIN, OUTPUT);}}\label{pinmodeled_builtin-output}}
\addcontentsline{toc}{paragraph}{\texttt{pinMode(LED\_BUILTIN,\ OUTPUT);}}

The first thing the code does is to initialize \texttt{LED\_BUILTIN} as
an output pin in the \texttt{setup()} function. Most Arduino series
boards default the onboard LED to digital pin 13. The constant
\texttt{LED\_BUILTIN} connects the onboard LED to pin 13. \#\#\#\#\#
\texttt{digitalWrite(LED\_BUILTIN,\ HIGH);} In the \texttt{loop()}
function, we set the \texttt{LED\_BUILTIN} pin to the ``on'' state,
outputting 5V or 3.3V voltage to this pin, which can be represented by
\texttt{HIGH}. However, note that all I/O pins on XIAO are 3.3V. Do not
input a voltage exceeding 3.3V, or it may damage the CPU. \#\#\#\#\#
\texttt{digitalWrite(LED\_BUILTIN,\ LOW);} What comes on must turn off.
This statement sets the \texttt{LED\_BUILTIN} pin to the ``off'' state,
outputting 0V voltage to this pin, which can be represented by
\texttt{LOW}. \#\#\#\#\# \texttt{delay(1000);} This is a delay
statement. It means that the LED can maintain the ``on'' or ``off''
state for 1 second, because the parameter in the function is in
milliseconds, so 1000 milliseconds is 1 second. After controlling the
``on'' and ``off'' statements of the LED, a delay must be added, and the
waiting time should be the same to ensure that the LED flashes evenly.
\#\#\#\# Upload the Program Next, we will learn how to upload the
program. Use the data cable in the kit to connect XIAO to the computer,
as shown in the figure.
\includegraphics{index_files/mediabag/1616585195669-ba0d43.png-averageHue=-e8e7e4-height=350-id=XW}
Choose the serial port of the development board from the ``Tools'' bar.
For Windows users, it is generally COM3 or a larger number. Select it as
shown in the figure below.

If several ports are displayed for selection, unplug the data cable,
reopen the ``Tools'' bar, and the port that disappears is the XIAO port.
Reconnect the circuit board and then select this serial port. After
selecting the board and the serial port, you can see the controller
model and corresponding serial port that have been set up in the lower
right corner of the IDE interface.
\includegraphics{index_files/mediabag/1684307022559-5118c8.jpeg} In Mac
or Linux systems, the serial port name is generally
\texttt{/dev/tty.usbmodem+number} or \texttt{/dev/cu.usbmodem+number},
as shown in the figure below.
\includegraphics{index_files/mediabag/1684307463342-df84ff.jpeg} Next,
we can upload the program. Before uploading, we can click the
\includegraphics{index_files/mediabag/1674004781256-2ef9b2.png-averageHue=-5e999d-clientId=u44ac5a}
(verify button) to verify whether the program is correct. If
``Compilation Completed'' is displayed, the program is correct.
\includegraphics{index_files/mediabag/1684307793146-ee2330.jpeg} Click
the\includegraphics{index_files/mediabag/1674004809585-a88427.png-averageHue=-5c979b-clientId=u44ac5a}
(upload button), the debug window will display ``Compiling
Project‚ÜíUpload''. When ``Upload Completed'' is displayed, you can see
the effect of the program running on XIAO, as shown in the upload
successful prompt window displayed on a Mac computer.
\includegraphics{index_files/mediabag/1684307706997-bd9fd7.jpeg}
\textgreater{} \#\#\# ‚ö†Ô∏è Note \textgreater{} When you start writing
code, you will often forget the rules of uppercase and lowercase,
punctuation, and make mistakes. Therefore, try to write code by yourself
instead of copying and pasting. After the example program is
successfully uploaded, try to create a new Sketch and start manually
inputting the code.

\hypertarget{task-2-complete-the-blink-example-by-connecting-an-external-led-to-seeed-xiao-esp32c3-without-led}{%
\section*{1.1.4 Task 2: Complete the Blink example by connecting an
external LED to Seeed XIAO ESP32C3 without
LED}\label{task-2-complete-the-blink-example-by-connecting-an-external-led-to-seeed-xiao-esp32c3-without-led}}
\addcontentsline{toc}{section}{1.1.4 Task 2: Complete the Blink example
by connecting an external LED to Seeed XIAO ESP32C3 without LED}

\markright{1.1.4 Task 2: Complete the Blink example by connecting an
external LED to Seeed XIAO ESP32C3 without LED}

If the XIAO you have on hand is Seeed XIAO ESP32C3, since it does not
have an onboard LED available for users, in order to run the Blink
program, you need to first connect an LED to the \texttt{D10} pin of the
board, as shown below:
\includegraphics{index_files/mediabag/1666778092446-9a6e72.png-averageHue=-d8d4cb-clientId=u5d6c62}
\textgreater{} ‚ö†Ô∏è Note You must connect a resistor (about 150Œ©) in
series with the LED to limit the current flowing through the LED to
prevent the strong current from burning the LED.

Then copy the following program to the Arduino IDE:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Define the LED pin according to the pin diagram}
\DataTypeTok{int}\NormalTok{ led }\OperatorTok{=}\NormalTok{ D10}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
    \CommentTok{// Initialize the digital pin \textquotesingle{}led\textquotesingle{} as output}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}   \CommentTok{// Turn the LED on}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}               \CommentTok{// Wait for a second}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}    \CommentTok{// Turn the LED off}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}               \CommentTok{// Wait for a second}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/blob/main/code/L1_Blinks_XIAO_ESP32C3/L1_Blinks_XIAO_ESP32C3.ino}
\end{quote}

\hypertarget{code-analysis-1}{%
\subsubsection*{Code Analysis}\label{code-analysis-1}}
\addcontentsline{toc}{subsubsection}{Code Analysis}

\texttt{int\ led\ =\ D10;} Seeed XIAO ESP32C3 does not have an onboard
LED, so we did not preset an LED corresponding pin in the Arduino core.
Just now, we connected the LED to the \texttt{D10} pin, so we need to
declare it in the program. \texttt{pinMode(led,\ OUTPUT);} We defined
\texttt{led} as \texttt{D10}, and this step is to initialize led(D10) as
an output pin.

\hypertarget{extended-exercise}{%
\section*{1.1.5 Extended Exercise}\label{extended-exercise}}
\addcontentsline{toc}{section}{1.1.5 Extended Exercise}

\markright{1.1.5 Extended Exercise}

Rewrite the Blink program: In the example program, the LED is on and off
for 1 second each time, so it seems to blink evenly. Try adjusting the
waiting time to give the LED different blinking effects.

Hint:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
\OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}   
\NormalTok{    delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}                     
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}   
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}   
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/blob/main/code/L1_ll_Blinks_1_en/L1_ll_Blinks_1_en.ino}
\end{quote}

For XIAO ESP32C3, we also need to modify the pin definition part of the
program:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ led }\OperatorTok{=}\NormalTok{ D10}\OperatorTok{;}
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
\OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}   
\NormalTok{    delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}                     
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}   
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/blob/main/code/L1_ll_blinks_2_en/L1_ll_blinks_2_en.ino}
\end{quote}

\bookmarksetup{startatroot}

\hypertarget{using-the-button-switch-on-the-xiao-expansion-board-to-control-an-led-light}{%
\chapter*{1.2 Using the Button Switch on the XIAO Expansion Board to
Control an LED
Light}\label{using-the-button-switch-on-the-xiao-expansion-board-to-control-an-led-light}}
\addcontentsline{toc}{chapter}{1.2 Using the Button Switch on the XIAO
Expansion Board to Control an LED Light}

\markboth{1.2 Using the Button Switch on the XIAO Expansion Board to
Control an LED Light}{1.2 Using the Button Switch on the XIAO Expansion
Board to Control an LED Light}

In the previous section, we learned how to control an LED light to blink
using only the Seeed Studio XIAO and the onboard LED light. However,
there was no interaction with the external environment, such as
controlling the LED light through light or sound. In this section, we
will introduce a simple sensor - the button switch, to form an automatic
control system of sensor-controller-actuator. Before starting the task,
we need to learn some basic knowledge, like what variables are and the
common program structures, so that we can better understand and run the
program. \#\# 1.2.1 Background Knowledge In the last section, we only
used the onboard LED light of the Seeed Studio XIAO without connecting
other modules. It could take quite some effort for beginners to use
Dupont wires to connect external sensors to a board the size of a thumb
and also involve a breadboard. Is there a simpler method? \#\#\# 1.2.1.1
Seeed Studio XIAO Expansion Board The
\href{https://www.seeedstudio.com/Seeeduino-XIAO-Expansion-board-p-4746.html}{Seeed
Studio XIAO Expansion Board}, only half the size of Raspberry Pi 4, is
powerful and can quickly and easily build prototypes and projects. The
board has a variety of peripherals such as OLED, RTC, expandable memory,
passive buzzer, RESET/User button, 5V servo/sensor connector, various
data interfaces\ldots{} You can explore the infinite possibilities of
Seeed Studio XIAO. The board also supports
\href{https://circuitpython.org/}{CircuitPython}. All models in the
Seeed Studio XIAO series have uniform specifications and support the
Seeed Studio XIAO
\href{https://seeedstudio.com/Grove-Shield-for-Seeeduino-XIAO-p-4621.html}{Grove
Shield} and
\href{https://www.seeedstudio.com/Seeeduino-XIAO-Expansion-board-p-4746.html}{Seeed
Studio XIAO Expansion Board}. The series includes
\href{https://www.seeedstudio.com/Seeeduino-XIAO-Arduino-Microcontroller-SAMD21-Cortex-M0+-p-4426.html}{XIAO
SAMD21},
\href{https://www.seeedstudio.com/XIAO-RP2040-v1-0-p-5026.html}{XIAO
RP2040},
\href{https://www.seeedstudio.com/Seeed-XIAO-BLE-nRF52840-p-5201.html}{XIAO
nRF52840},
\href{https://www.seeedstudio.com/Seeed-XIAO-BLE-Sense-nRF52840-p-5253.html}{XIAO
nRF52840 Sense},
\href{https://www.seeedstudio.com/Seeed-XIAO-ESP32C3-p-5431.html}{XIAO
ESP32C3} and
\href{https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html}{XIAO
ESP32S3}. The front and back function interfaces of the XIAO expansion
board are shown in the following figure:
\includegraphics{index_files/mediabag/1684898711192-4dab28.jpeg} To make
it easier and quicker to build projects with Seeed Studio XIAO, we
equipped it with a powerful expansion board. This board has a wealth of
onboard peripherals and can quickly connect to more electronic modules
to implement various functions. The expansion board brings out all the
pins of XIAO, as shown in the pin diagram below:
\includegraphics{index_files/mediabag/1615961051082-01f79e.jpeg-averageHue=-d5d2cf-height=517-id=u}
In most cases, the XIAO expansion board is suitable for all Seeed Studio
XIAO series products. When we need to use the XIAO expansion board, we
need to connect the XIAO development board to the corresponding position
on the expansion board, as shown in the figure below. Connect the pin
headers on the XIAO main board to the position circled in yellow on the
expansion board. Be sure to align it before pressing down to avoid
damaging the pins. After that, we can start working on projects in
combination with the expansion board.
\includegraphics{index_files/mediabag/1615806858604-8e938c.png-averageHue=-858585-height=308-id=Gz}
\textgreater{} ‚ö†Ô∏è Note \textgreater{} Please first plug the Seeed Studio
XIAO into the two female headers on the expansion board, and then plug
in the Type-C power supply, otherwise it will damage the Seeed Studio
XIAO and the expansion board.

\hypertarget{three-basic-structures-of-programs}{%
\subsection*{1.2.1.2 Three Basic Structures of
Programs}\label{three-basic-structures-of-programs}}
\addcontentsline{toc}{subsection}{1.2.1.2 Three Basic Structures of
Programs}

The three basic structures of programs are sequential structure,
selection structure, and loop structure.
\includegraphics{index_files/mediabag/1684899917009-c627d8.jpeg}
\#\#\#\# Sequential Structure As the name suggests, the program in a
sequential structure is executed in the order of the statements. It is
the most basic and simple program structure. As shown in the figure
below, the program will first execute the operation in the S1 box, then
the operation in the S2 box, and so on.
\includegraphics{index_files/mediabag/1615875380657-0bc53b.png-averageHue=-232323-height=256-id=gD}
\#\#\#\# Selection Structure In a program,sometimes we need to make
judgments based on the situation to decide the next step. For instance,
the program might need to judge the light value in the current
environment. If the light value is high, indicating a bright
environment, there's no need to light up the light. If the light value
is low, indicating a dim environment, then it's necessary to turn on the
light. In such cases, we use a selection structure. As shown in the
following figures, the selection structure will judge whether the
condition is fulfilled. If ``True'', it executes S1; if ``False'', it
executes S2; or if ``True'', it executes S1, if ``False'', it exits the
selection structure.
\includegraphics{index_files/mediabag/1684903938231-98df97.jpeg}
\#\#\#\#\# The if Statement The if statement is the most common
selection structure, which executes the following statement when the
given expression is true. The if statement has three structural forms as
shown in the following example. Simple branch structure: Execute when
the condition is fulfilled.

\begin{verbatim}

if (expression) {
  statement;
}
\end{verbatim}

Dual branch structure: Execute statement1 when the condition is
fulfilled, otherwise execute statement2.

\begin{verbatim}
if (expression) {
  statement1;
}
else {
  statement2;
}
\end{verbatim}

Multi-branch structure: Use nested if statements to judge different
situations.

\begin{verbatim}
if (expression1) {
  statement1;
}
else if (expression2) {
  statement2;
}
else if (expression3) {
  statement3;
}
\end{verbatim}

\hypertarget{switchcase-statement}{%
\paragraph*{\texorpdfstring{\texttt{switch‚Ä¶‚Ä¶case}
Statement}{switch\ldots\ldots case Statement}}\label{switchcase-statement}}
\addcontentsline{toc}{paragraph}{\texttt{switch‚Ä¶‚Ä¶case} Statement}

When dealing with multiple selection branches, using an
``if\ldots\ldots else'' structure to write a program can be quite
lengthy. In this case, it's much more convenient to use a
\texttt{switch} statement. The \texttt{switch} structure compares the
expression in parentheses with the constants after \texttt{case}. If
they match, it executes the corresponding statement and exits the
structure via a \texttt{break} statement. If none match, it runs the
statement after \texttt{default}. It's important to note that the
expression in parentheses after \texttt{switch} must be of integer or
character type.
\includegraphics{index_files/mediabag/1684907532843-f65caf.jpeg}

\begin{verbatim}
switch (expression) {
  case constant_expression1:
    statement1;
    break;
  case constant_expression2:
    statement2;
    break;
    ‚Ä¶‚Ä¶
  default:
    statementn;
    break;
}
\end{verbatim}

\hypertarget{break-statement}{%
\paragraph*{\texorpdfstring{\texttt{break}
Statement}{break Statement}}\label{break-statement}}
\addcontentsline{toc}{paragraph}{\texttt{break} Statement}

The \texttt{break} statement can only be used in a \texttt{switch}
multi-branch selection structure and loop structures. It is used to
terminate the current program structure, allowing the program to jump to
subsequent statements for execution.

\hypertarget{loop-structure}{%
\subsubsection*{Loop Structure}\label{loop-structure}}
\addcontentsline{toc}{subsubsection}{Loop Structure}

A loop structure is used when a part of the program needs to be executed
repeatedly, based on given judgment conditions to determine whether to
continue executing a certain operation or exit the loop. There are three
common types of loop statements:

\hypertarget{while-loop}{%
\paragraph*{\texorpdfstring{\texttt{while}
Loop}{while Loop}}\label{while-loop}}
\addcontentsline{toc}{paragraph}{\texttt{while} Loop}

The \texttt{while} loop is a type of ``when'' loop that executes the
statements in the loop body when a certain condition is met.
\includegraphics{index_files/mediabag/1684908451724-796c9f.jpeg}

\begin{verbatim}
while (expression) {
  statement;
}
\end{verbatim}

\hypertarget{dowhile-loop}{%
\paragraph*{\texorpdfstring{\texttt{do‚Ä¶‚Ä¶while}
Loop}{do\ldots\ldots while Loop}}\label{dowhile-loop}}
\addcontentsline{toc}{paragraph}{\texttt{do‚Ä¶‚Ä¶while} Loop}

This is a type of ``until'' loop. The statement in the loop body is
executed once before the expression is evaluated. If the expression is
true, the loop continues.
\includegraphics{index_files/mediabag/1684908453750-2896ad.jpeg}

\begin{verbatim}
do {
  statement;
} while (expression);
\end{verbatim}

\hypertarget{for-loop}{%
\paragraph*{\texorpdfstring{\texttt{for}
Loop}{for Loop}}\label{for-loop}}
\addcontentsline{toc}{paragraph}{\texttt{for} Loop}

This includes three expressions: Expression1 for initialization,
Expression2 for judgment, and Expression3 for increment.
\includegraphics{index_files/mediabag/1684908867915-598217.jpeg}

\begin{verbatim}
for (Expression1; Expression2; Expression3) {
  statement;
}
\end{verbatim}

In addition to the above loop statements, there are control statements,
\texttt{break} and \texttt{continue}, in the loop structure used to
prematurely end the loop or exit the loop. In this lesson, we just need
to understand these program structures. In later courses, we will
gradually master them through project examples. \#\# 1.2.2 Task 1:
Control the LED on the XIAO using the button on the XIAO expansion board
\#\#\#\# Analysis The effect we want to achieve is that when the button
is pressed, the LED lights up; when the button is released, the LED goes
off. The program is written in three steps:

\begin{itemize}
\tightlist
\item
  Define pins and create variables.
\item
  Initialize and set pin status.
\item
  Read the button status, implement condition judgment. If the button is
  pressed, the light is on, otherwise, the light is off.
\end{itemize}

\begin{quote}
\hypertarget{variable}{%
\subsection*{Variable}\label{variable}}
\addcontentsline{toc}{subsection}{Variable}

In a program, a value that can change is called a variable. For example,
defining an integer variable \texttt{i} as \texttt{int\ i;}. We can
assign a value to the variable at the same time as we define it, such as
\texttt{int\ i\ =0;}. Furthermore, depending on the data type, different
statements are used to define variables, such as defining a floating
point number, \texttt{float\ x\ =\ 1.9;}, and so on. For more details,
refer to the Arduino data types and constants documentation
\url{https://www.arduino.cc/reference/en/\#variables}.
\end{quote}

\hypertarget{writing-the-program}{%
\subsubsection*{Writing the Program:}\label{writing-the-program}}
\addcontentsline{toc}{subsubsection}{Writing the Program:}

\textbf{Step 1:} Define pins and create variables. The on-board button
switch on the XIAO expansion board is \texttt{D1}, so we define it as
pin 1 and set a variable for the button status. Note that
\texttt{LED\_BUILTIN} will set the LED to the correct pin, so we don't
need to manually define it:

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}  \CommentTok{// The on{-}board button switch on the XIAO expansion board is D1, which we define as pin 1}
\CommentTok{// If you are using XIAO RP2040, please change 1 to D1}
\DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}  \CommentTok{// buttonState is a variable to store the button status}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Set pin status. Set the LED pin to output status and
the button pin to input pull-up status. Use \texttt{INPUT\_PULLUP} to
enable internal pull-up resistors. When the button is not pressed, it
returns \texttt{1} or \texttt{HIGH} (high level). When the button is
pressed, it returns \texttt{0} or \texttt{LOW} (low level).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}\CommentTok{// Set the LED pin to output status}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT\_PULLUP}\OperatorTok{);}\CommentTok{// Set the button pin to input status}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Continuously read the button status. If the button is
pressed, the light is on, otherwise, the light is off. Because the
on-board LED of the XIAO is negative logic, when the button is pressed
and returns \texttt{0}, the LED is on; when it returns \texttt{1}, the
LED is off.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \CommentTok{// Read the button status and store it in the buttonState variable}
\NormalTok{    buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);}  
    \CommentTok{// Check whether the button is pressed, if the button is pressed}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{buttonState }\OperatorTok{==}\NormalTok{ HIGH}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// Turn on the LED:}
\NormalTok{        digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{else} \OperatorTok{\{}
        \CommentTok{// Turn off the LED:}
\NormalTok{        digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILTIN}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/blob/main/code/L2_Button_XIAO_en/L2_Button_XIAO_en.ino}
\end{quote}

\hypertarget{uploading-the-program}{%
\subsubsection*{Uploading the Program}\label{uploading-the-program}}
\addcontentsline{toc}{subsubsection}{Uploading the Program}

We upload the program we wrote to the hardware. First, use the data
cable in the kit to connect the XIAO to the computer.
\includegraphics{index_files/mediabag/1684977221668-62259e.jpeg} Note
the position of the buttons on the XIAO extensions used for testing in
the figure. Then click the verify button
\includegraphics{index_files/mediabag/1674004781256-2ef9b21.png-averageHue=-5e999d-clientId=u44ac5a}
to verify the program. If it is correct, click the upload button
\includegraphics{index_files/mediabag/1674004809585-a884271.png-averageHue=-5c979b-clientId=u44ac5a}
to upload the program to the hardware. When the debugging area displays
``Done uploading.'', we can press the button to see if the LED lights
up.
\includegraphics{index_files/mediabag/1616585235857-fdcadd.jpeg-averageHue=-dad2cd-height=2273-id=}
\textgreater{} ‚ö†Ô∏è Note There are two identical buttons on the expansion
board. One is the RESET button near the Type-C interface, and the other
is the user-defined button near the lithium battery interface. Test with
the one near the lithium battery interface.

\hypertarget{task-2-use-the-button-on-the-xiao-expansion-board-to-control-the-external-led-on-the-xiao-esp32c3}{%
\subsection*{1.2.3 Task 2: Use the button on the XIAO expansion board to
control the external LED on the XIAO
ESP32C3}\label{task-2-use-the-button-on-the-xiao-expansion-board-to-control-the-external-led-on-the-xiao-esp32c3}}
\addcontentsline{toc}{subsection}{1.2.3 Task 2: Use the button on the
XIAO expansion board to control the external LED on the XIAO ESP32C3}

For the Seeed XIAO ESP32C3, it doesn't have an on-board LED for users to
use. To run the Blink program, you need to first connect an LED to the
\texttt{D10} pin of the board as shown:
\includegraphics{index_files/mediabag/1666778092446-9a6e721.png-averageHue=-d8d4cb-clientId=u5d6c62}
\textgreater{} ‚ö†Ô∏è Note Be sure to add a resistor (about 150Œ©) in series
with the LED to limit the current flowing through the LED to prevent
overcurrent from burning out the LED.

Then copy the following program into the Arduino IDE:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{ * Button controlling external LED of XIA}

\CommentTok{Apologies for the confusion. It seems that there was an issue with quoting text from the document. Let\textquotesingle{}s continue:}

\CommentTok{\#\#\#\# Task 2: Use the button on the XIAO expansion board to control the external LED on the XIAO ESP32C3}
\CommentTok{For the Seeed XIAO ESP32C3, it doesn\textquotesingle{}t have an on{-}board LED for users to use. To execute the Blink program, you first need to connect an LED to the board\textquotesingle{}s \textasciigrave{}D10\textasciigrave{} pin as shown. }

\CommentTok{\textgreater{} ‚ö†Ô∏è Note: Make sure to add a resistor (about 150Œ©) in series with the LED to limit the current flowing through the LED and prevent overcurrent from burning out the LED.}

\CommentTok{Then, copy the following program into the Arduino IDE:}
\CommentTok{\textasciigrave{}\textasciigrave{}\textasciigrave{}cpp}
\CommentTok{/*}
\CommentTok{ * Button controlling external LED of XIAO ESP32C3}
\CommentTok{ */}

\AttributeTok{const} \DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}     \CommentTok{// The pin number of the button}
\DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}    \CommentTok{// Variable for reading the button status}
\DataTypeTok{int}\NormalTok{ led }\OperatorTok{=}\NormalTok{ D10}\OperatorTok{;}  \CommentTok{// Pin number of the LED}

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
  \CommentTok{// Initialize the LED pin as an output:}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
  \CommentTok{// Initialize the button pin as an input:}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT\_PULLUP}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
  \CommentTok{// Read the state of the button:}
\NormalTok{  buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);}
  \CommentTok{// Check if the button is pressed. If it is, the button state is HIGH}
  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{buttonState }\OperatorTok{==}\NormalTok{ HIGH}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Turn the LED on:}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);}
  \OperatorTok{\}}
  \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// Turn the LED off:}
\NormalTok{    digitalWrite}\OperatorTok{(}\NormalTok{led}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L2_Button_XIAO_ESP32C3_en}
\end{quote}

\hypertarget{powering-xiao-with-an-external-battery}{%
\subsubsection*{Powering XIAO with an external
battery}\label{powering-xiao-with-an-external-battery}}
\addcontentsline{toc}{subsubsection}{Powering XIAO with an external
battery}

When demonstrating the effect, in addition to using a data cable to
power the computer, you can also use an external lithium battery. This
makes it convenient to move and do projects, as shown in the picture.
\includegraphics{index_files/mediabag/1616585803526-8cf1d0.png-averageHue=-b6b5b3-height=296-id=W0}
\includegraphics{index_files/mediabag/1616585167964-b133a1.jpeg-averageHue=-f0efee-height=2320-id=}
\#\#\# 1.2.4 Expanded Exercise \#\#\#\# Flow Chart Before writing the
program, you can first draw a flow chart of the program to help organize
your thoughts. The common flow chart symbols are as follows:
\includegraphics{index_files/mediabag/1684910895830-8ac3d9.jpeg} The
button-controlled LED program we implemented in this section is
represented by the following flow chart. You can try drawing it
yourself.
\includegraphics{index_files/mediabag/1684911242655-4e6036.jpeg}

\bookmarksetup{startatroot}

\hypertarget{transforming-xiao-and-its-expansion-board-into-a-morse-code-transmitter}{%
\chapter*{1.3 Transforming XIAO and its Expansion Board into a Morse
Code
Transmitter}\label{transforming-xiao-and-its-expansion-board-into-a-morse-code-transmitter}}
\addcontentsline{toc}{chapter}{1.3 Transforming XIAO and its Expansion
Board into a Morse Code Transmitter}

\markboth{1.3 Transforming XIAO and its Expansion Board into a Morse
Code Transmitter}{1.3 Transforming XIAO and its Expansion Board into a
Morse Code Transmitter}

Everyone knows that ``SOS'' is an internationally recognized emergency
signal, a form of Morse code. Today, we will transform Seeed Studio's
XIAO into a Morse code transmitter. We will try to make the onboard
buzzer of the expansion board send signals automatically. In addition,
we will learn how to control the buzzer manually with a button. \#\#
1.3.1 Background Knowledge \#\#\# 1.3.1.1 Buzzer A buzzer is an
integrated electronic sound device that generates sound based on the
input of an electrical signal. Buzzers are often installed on electronic
products for sound generation. There are two types of buzzers: active
(source buzzers) and passive (sourceless buzzers).

\begin{itemize}
\tightlist
\item
  \textbf{Active Buzzers:} These buzzers have a simple oscillation
  circuit inside. When connected to a DC power supply, the buzzer can
  convert a constant DC into a certain frequency pulse signal, thereby
  driving the internal aluminum sheet to vibrate and make a sound.
  Active buzzers can usually only emit some fixed-pitch (frequency)
  sounds and are widely used in the sound devices of computers,
  printers, copiers, alarms, electronic toys, car electronics, phones,
  timers, and other electronic products.
\item
  \textbf{Passive Buzzers:} These buzzers work similarly to
  loudspeakers. They don't have an internal oscillator and need to be
  connected to a changing current signal to work. They usually use
  different frequency square wave signals for driving. The sound
  generated by passive buzzers will change according to the change in
  input signal, and they can output a variety of sounds like speakers,
  not just emitting a fixed single tone (frequency).
\end{itemize}

\includegraphics{index_files/mediabag/1684913092337-d9a94a.jpeg} The
standalone buzzer module is shown in the figure below.
\includegraphics{index_files/mediabag/1605150283792-1b1c9d.png-averageHue=-c4c7c1-height=234-id=an}
In the Seeed Studio XIAO expansion board, there is an onboard passive
buzzer connected to pin A3. We can output PWM pulse signals to this pin
to control the buzzer.
\includegraphics{index_files/mediabag/1612687823459-80d127.png-averageHue=-686866-height=303-id=Ky}
\#\#\# 1.3.1.2 \texttt{tone()} and \texttt{noTone()} Functions \#\#\#\#
\texttt{tone()}Function The \texttt{tone()}function can generate a fixed
frequency PWM signal to drive a passive buzzer to make a sound, and it
can define the frequency and duration of the sound. \#\#\#\#\# Syntax:
\texttt{tone(pin,\ frequency);}
\texttt{tone(pin,\ frequency,\ duration);} \#\#\#\#\# Parameters:
\texttt{pin:} The pin to which the buzzer is connected (in the Seeed
Studio XIAO expansion board, it's A3). \texttt{frequency:}The frequency
of the sound (unit: Hz), the type allowed is unsigned integer.
\texttt{duration:}The duration of the sound (unit: milliseconds, this
parameter is optional), the type allowed is unsigned long.

\hypertarget{notone-function}{%
\subsubsection*{\texorpdfstring{\texttt{noTone()}
Function}{noTone() Function}}\label{notone-function}}
\addcontentsline{toc}{subsubsection}{\texttt{noTone()} Function}

This function is used to stop the sound of the buzzer controlled by the
\texttt{tone()} function. If there is no sound generated, the function
is invalid. \#\#\#\#\# Syntax: \texttt{noTone(pin);} \#\#\#\#\#
Parameters: \texttt{pin:} The pin to stop the sound. \#\#\# 1.3.1.3
Common Operators In previous studies, we have used some operators. Next,
we will learn about common types of operators and their usage methods.
\#\#\#\# Arithmetic Operators: \textbar{} Operator \textbar{}
Explanation \textbar{} \textbar{} --- \textbar{} --- \textbar{}
\textbar{} = \textbar{} Assignment operator \textbar{} \textbar{} +
\textbar{} Addition operator \textbar{} \textbar{} - \textbar{}
Subtraction operator \textbar{} \textbar{} * \textbar{} Multiplication
operator \textbar{} \textbar{} / \textbar{} Division operator \textbar{}
\textbar{} \% \textbar{} Modulus operator \textbar{}

\hypertarget{comparison-operators}{%
\subsubsection*{Comparison Operators:}\label{comparison-operators}}
\addcontentsline{toc}{subsubsection}{Comparison Operators:}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Explanation \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
!= & Not equal to \\
\textless{} & Less than \\
\textless= & Less than or equal to \\
== & Equal to \\
\textgreater{} & Greater than \\
\textgreater= & Greater than or equal to \\
\end{longtable}

\hypertarget{boolean-operators}{%
\subsubsection*{Boolean Operators:}\label{boolean-operators}}
\addcontentsline{toc}{subsubsection}{Boolean Operators:}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Explanation \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\&\& & Logical ``and'' \\
! & Logical ``not'' \\
\textbar\textbar{} & Logical ``or'' \\
\end{longtable}

\hypertarget{compound-operators}{%
\subsubsection*{Compound Operators:}\label{compound-operators}}
\addcontentsline{toc}{subsubsection}{Compound Operators:}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Explanation \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
++ & Self-increment \\
+= & Compound addition \\
-- & Self-decrement \\
-= & Compound subtraction \\
\end{longtable}

For detailed explanations, see:
\url{https://www.arduino.cc/reference/en/} \#\#\# 1.3.1.4 Morse Code
Morse code is a method of expressing information in telecommunication,
named after the inventor of the telegraph, Samuel Morse.
\includegraphics{index_files/mediabag/1603846193944-6ea738.jpeg-averageHue=-8b867f-height=317-id=U}
Source of the picture: \url{https://en.wikipedia.org/wiki/Samuel_Morse}
The international Morse code encodes the 26 English letters A to Z, some
non-English letters, Arabic numbers, and a small number of punctuation
marks and prosigns. There is no distinction between upper and lower case
letters. Each Morse code symbol consists of a series of dots (¬∑) and
dashes (---). The duration of a dot is the basic unit of time
measurement in Morse code transmission. The duration of a dash is three
times the duration of a dot. After each dot or dash in a character,
there is a time when the signal is absent, called a space, equal to the
duration of a dot. For example, the standard emergency distress signal
SOS is expressed in Morse code as shown in the figure below.
\includegraphics{index_files/mediabag/1603846441960-5e9f2c.png-averageHue=-5a0000-height=10-id=bGB}
If it's expressed in sound, it sounds like this. As can be seen, Morse
code essentially encodes duration to transmit signals. With such
encoding rules, people can present duration in many ways, such as
intermittently emitting sounds, intermittently lighting up searchlights,
etc., to ultimately achieve the purpose of sending information.
\includegraphics{index_files/mediabag/1603846838461-ea51e7.jpeg-averageHue=-7f909f-height=962-id=W}
Source of the picture:\url{https://en.wikipedia.org/wiki/Morse_code}
Morse code was used most when communication was not developed. People
used Morse code for long-distance information transmission through
radio. The old device below is an early telegraph device, where the
operator controls the long and short signals of the telegraph by
pressing the circular handle on the right.
\includegraphics{index_files/mediabag/1603846816937-54826e.jpeg-averageHue=-c7c7bf-height=657-id=d}
Source of the picture: \url{https://en.wikipedia.org/wiki/Morse_code} If
you are interested in Morse code, you can visit the following website.
The website can translate the letters and numbers you enter into Morse
code and provide a download of the sound file.
\url{https://morsedecoder.com/} \#\# 1.3.2 Task 1: Automatic
Broadcasting of ``SOS'' \#\#\# Analysis Automatic broadcasting means
that when the control board is started, the onboard buzzer automatically
emits the Morse code of ``SOS''. The program is written in three steps:

\begin{itemize}
\tightlist
\item
  Define the buzzer pin
\item
  Initialization, setting the state of the buzzer pin
\item
  Loop the buzzer to play the Morse code of ``SOS''
\end{itemize}

Let's first look at how to reflect the Morse code of ``SOS'' through the
program. If you import the audio file of Morse code into the audio
editing software, you can see the waveform of the sound and the duration
of each syllable, which is generally divided into long and short sounds.
To facilitate understanding and programming, we use a binary way to mark
the switch of the buzzer, 1 indicates the buzzer is on, 0 indicates the
buzzer is off, and the gray number represents how long the current
status needs to last. After a Morse code ends, because it needs to be
looped, you need to leave time between the two Morse codes, here it is
set to 0.8 seconds.
\includegraphics{index_files/mediabag/1603866605792-3b94b3.png-averageHue=-646464-height=529-id=yQ}

To emit a short sound, which corresponds to a dot in Morse code, from
the buzzer, you can use the following code in Arduino:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
\NormalTok{delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\NormalTok{noTone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{);}
\NormalTok{delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

In this code snippet:

\begin{itemize}
\tightlist
\item
  \texttt{tone(pinBuzzer,\ 200)} generates a sound at a frequency of 200
  Hz on the buzzer connected to the \texttt{pinBuzzer} pin.
\item
  \texttt{delay(100)} waits for 100 milliseconds. This is how long the
  sound lasts.
\item
  \texttt{noTone(pinBuzzer)} stops the sound on the buzzer.
\item
  The final \texttt{delay(100)} ensures there's a pause before the next
  sound is generated, representing the space between the signals.
\end{itemize}

The code you provided is a complete Arduino program for emitting the SOS
Morse code signal using a buzzer. Here is the English explanation:
\#\#\#\# Writing the Program \textbf{Step 1:} Define pins and create
variables

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ pinBuzzer }\OperatorTok{=} \DecValTok{3}\OperatorTok{;} \CommentTok{// Define the buzzer on pin 3, if you\textquotesingle{}re using XIAO RP2040/XIAO ESP32, change 3 to A3}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Set pin state

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);} \CommentTok{// Set the buzzer pin to output state}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Loop to play ``SOS'' Morse code

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \CommentTok{// Emit three short signals:}
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
\NormalTok{        tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\NormalTok{        noTone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{200}\OperatorTok{);}

    \CommentTok{// Emit three long signals:}
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
\NormalTok{        tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{300}\OperatorTok{);}
\NormalTok{        noTone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{200}\OperatorTok{);}

    \CommentTok{// Emit three short signals again:}
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)\{}
\NormalTok{        tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\NormalTok{        noTone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{);}
\NormalTok{        delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{800}\OperatorTok{);} \CommentTok{// Wait before repeating}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L3_SOS_XIAO_en}
\end{quote}

\hypertarget{uploading-the-program-1}{%
\subsubsection*{Uploading the Program}\label{uploading-the-program-1}}
\addcontentsline{toc}{subsubsection}{Uploading the Program}

To upload the program to your hardware, connect your XIAO to your
computer using the data cable included in the kit. After this, click on
the verify button
\includegraphics{index_files/mediabag/1674004781256-2ef9b212.png-averageHue=-5e999d-clientId=u44ac5a}
to check your program. If it passes verification, click on the upload
button
\includegraphics{index_files/mediabag/1674004809585-a8842712.png-averageHue=-5c979b-clientId=u44ac5a}
to upload the program to your hardware. When the debug area shows ``Done
uploading.'', you can listen to the Morse code sound. Is it the rhythm
you expected?
\includegraphics{index_files/mediabag/1684977221668-62259e.jpeg} Note
the position of the buttons on the XIAO extensions used for testing in
the figure. \#\# 1.3.3 Task 2: Control the buzzer with a button
Controlling the buzzer with a button to emit Morse code can be done
manually. The code logic is simple: use an if statement to determine if
the button is pressed. If it is, then the buzzer emits a sound. \#\#\#\#
Analysis The program is also written in three steps:

\begin{itemize}
\tightlist
\item
  Define the buzzer and button pins.
\item
  Initialize by setting the state of the buzzer and button pins.
\item
  Determine whether the button is pressed; if pressed, emit a sound.
  \#\#\#\# Write the program: \textbf{Step 1:} Define the buzzer and
  button pins
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// The button is on pin 1, if you are using XIAO RP2040/XIAO ESP32, please change 1 to D1}
\DataTypeTok{int}\NormalTok{ pinBuzzer }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}\CommentTok{// The buzzer is on pin 3, if you are using XIAO RP2040/XIAO ESP32, please change 3 to A3}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Set the button and buzzer pin states

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
    \CommentTok{// Set the buzzer pin as output:}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
    \CommentTok{// Set the button pin as input:}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT\_PULLUP}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Check the button state, if the button is pressed, the
buzzer sounds. Here, the \texttt{tone()} function is used to control the
passive buzzer to make a sound.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \CommentTok{// buttonState is the button variable, read the button state and store it in the variable:}
    \DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);}

    \CommentTok{// Check if the button is pressed, if the button is pressed:}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{buttonState }\OperatorTok{==}\NormalTok{ LOW}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// The buzzer sounds with a frequency of 200, for a duration of 200 milliseconds}
\NormalTok{        tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
‚ö†Ô∏è Note: There are two identical buttons on the expansion board, one is
the RESET button, which is closer to the Type-C interface, and the other
is the user-defined button, which is closer to the lithium battery
interface. When testing, press the one closer to the lithium battery
interface.
\end{quote}

The complete program is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{ * Button{-}SOS}
\CommentTok{ */}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// The button is on pin 1, if you are using XIAO RP2040/XIAO ESP32, please change 1 to D1!}
\DataTypeTok{int}\NormalTok{ pinBuzzer }\OperatorTok{=} \DecValTok{3}\OperatorTok{;} \CommentTok{// The buzzer is on pin 3, if you are using XIAO RP2040/XIAO ESP32, please change 3 to A3!}
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
  \CommentTok{// Set the buzzer pin as output:}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);}
  \CommentTok{// Set the button pin as input:}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT\_PULLUP}\OperatorTok{);}
\OperatorTok{\}}
 
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
  \CommentTok{// buttonState is the button variable, read the button state and store it in the variable:}
  \DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);}
 
  \CommentTok{// Check if the button is pressed, if the button is pressed:}
  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{buttonState }\OperatorTok{==}\NormalTok{ LOW}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// The buzzer sounds with a frequency of 200, for a duration of 200 milliseconds}
\NormalTok{    tone}\OperatorTok{(}\NormalTok{pinBuzzer}\OperatorTok{,} \DecValTok{200}\OperatorTok{,} \DecValTok{200}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L3_ButtonSOS_XIAO_en}
\end{quote}

\hypertarget{uploading-the-program-2}{%
\subsubsection*{Uploading the program}\label{uploading-the-program-2}}
\addcontentsline{toc}{subsubsection}{Uploading the program}

We will upload the written program to the hardware. First, connect the
XIAO to your computer using the data cable from the kit.
\includegraphics{index_files/mediabag/1615883758760-2df323.png-averageHue=-dddcdc-height=1073-id=q}
Next, click the
\includegraphics{index_files/mediabag/1674004781256-2ef9b2123.png-averageHue=-5e999d-clientId=u44ac5a}
(verify button) to validate the program. If there are no errors, click
the
\includegraphics{index_files/mediabag/1674004809585-a88427123.png-averageHue=-5c979b-clientId=u44ac5a}
(upload button) to upload the program to the hardware. When the debug
area shows ``Done uploading.'', we can press the button on the XIAO
expansion board and test whether the buzzer will sound.

\hypertarget{extended-exercise-1}{%
\section*{1.3.4 Extended Exercise}\label{extended-exercise-1}}
\addcontentsline{toc}{section}{1.3.4 Extended Exercise}

\markright{1.3.4 Extended Exercise}

The passive buzzer can emit different pitches to form a simple melody.
Research how to make Arduino play notes through a search engine. You can
open the extended exercise code to experience the effect of playing
``Happy Birthday'' with the buzzer. \textgreater{} Get this program from
Github \textgreater{}
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L3_HappyBirthday_en}

\bookmarksetup{startatroot}

\hypertarget{monitor-knob-value-changes-with-serial-monitor}{%
\chapter*{1.4 Monitor Knob Value Changes with Serial
Monitor}\label{monitor-knob-value-changes-with-serial-monitor}}
\addcontentsline{toc}{chapter}{1.4 Monitor Knob Value Changes with
Serial Monitor}

\markboth{1.4 Monitor Knob Value Changes with Serial Monitor}{1.4
Monitor Knob Value Changes with Serial Monitor}

When we write a few lines of code to control the board to light up the
LED, or to use a button switch to control the buzzer, we can intuitively
see the working state of these external hardware. If it achieves our
expected results, it is very fortunate. What if it doesn't? The program
compiles without error, where is the mistake? It would be nice if they
could speak up. In this section, we will learn how to communicate with
the computer through the serial monitor and check the running status and
information of the program and hardware. \#\# 1.4.1 Background Knowledge
\#\#\# 1.4.1.1 Rotary Potentiometer The rotary potentiometer, although
it doesn't seem common, has a very wide range of uses in household
appliances and industrial equipment. For example, the volume knob on the
sound system.
\includegraphics{index_files/mediabag/1615884101164-d2520b.png-averageHue=-e3e2e0-height=293-id=Uz}
The rotary potentiometer can produce an analog output value between 0
and VCC (the voltage of the connected circuit) on its connected pins. By
rotating the knob, you can change the output voltage value. The range of
the knob's angle is 300¬∞, and the output value is 0-1023. We can use the
rotary potentiometer to control the LED light to show brightness
changes, or control the servo to rotate at different angles, etc.
\includegraphics{index_files/mediabag/1613485032481-248875.png-averageHue=-a99681-height=168-id=sy}
\#\#\# 1.4.1.2 Analog I/O In the Arduino series of development boards,
the pins with ``A'' in front of the pin number are analog input pins. We
can read the analog value on these pins to achieve the effect we want.
\#\#\#\# Analog Signal In life, analog signals are everywhere, such as
the change in sound, light, temperature, etc., the frequency, amplitude,
etc. of the signal can change continuously with time.
\includegraphics{index_files/mediabag/1684917511360-8d2327.jpeg} So how
do we read the analog value of the pin through the development board?
The analog input pin has an ADC (analog-to-digital converter), which can
convert the external input analog signal into a digital signal that the
development board can recognize, thereby achieving the function of
reading in analog values, i.e., it can convert a 0-5V voltage signal
into an integer value of 0-1023.

\begin{itemize}
\tightlist
\item
  \texttt{analogRead();}
\end{itemize}

Read the value from the specified analog pin. \textbf{Syntax}
\texttt{analogRead(pin);} \textbf{Parameters} \texttt{pin:}The name of
the analog input pin to be read.

\begin{itemize}
\tightlist
\item
  \texttt{analogWrite();}
\end{itemize}

Corresponding to analog input is analog output. We use the
\texttt{analogWrite()} function to achieve this function. It should be
noted that when using this function, it is only through a special way to
output different voltages to achieve the effect of approximate analog
values. This method is called PWM pulse width modulation, so we are
writing PWM square waves to the specified pin, not the true analog
value. \textbf{Syntax} \texttt{analogWrite(pin,\ value);}
\textbf{Parameters} \texttt{pin:}The pin to output PWM, allowed data
type: int. \texttt{value:} Duty cycle, between 0-255, allowed data type:
int. \textgreater{} \#\#\# PWM Pulse Width Modulation \textgreater{}
Pulse width modulation (PWM) is a way to achieve analog results through
digital output. Simply put, you can control the charging current by
adjusting the period of PWM and the duty cycle of PWM. As shown in the
figure, the voltage is switched back and forth between 0V (low level)
and 5V (high level). A switchback is a period. In this period, if the
time of high voltage is 25\% and the time of low voltage is 75\%, the
duty cycle is 25\%, and the output voltage is 5V. \textgreater{} When we
write a few lines of code to control the lighting of LEDs on the
development board, or use button switches to control the buzzer, we can
directly observe the working status of these external hardware. If it
achieves our expected results, we are lucky. But what if it doesn't? The
program compiles without errors, so where is the problem? It would be
nice if they could talk. In this section, we will learn how to
communicate with the computer, monitor the running status and
information of the program and hardware through the serial monitor.
\textgreater{}
\includegraphics{index_files/mediabag/1613458123437-662c75.png-averageHue=-0b0b0b-height=438-id=F1}

\hypertarget{serial-communication}{%
\subsection*{1.4.1.3 Serial Communication}\label{serial-communication}}
\addcontentsline{toc}{subsection}{1.4.1.3 Serial Communication}

When we want to communicate with other devices using XIAO, the most
common method is serial communication. All Arduino series development
boards have this functionality. As we know, computers understand binary
data (like 1010). Therefore, among electronic devices, serial
communication achieves its function by sending and receiving such data.
The key component to implement this function is the USART (Universal
Synchronous/Asynchronous Receiver Transmitter). In the Arduino IDE, we
can observe the sent and received data through the Serial Monitor, and
we need related serial communication functions to implement this
feature.
\includegraphics{index_files/mediabag/1684918306693-34cb50.jpeg}

\begin{itemize}
\tightlist
\item
  \texttt{**Serial.begin()Ôºõ**}
\end{itemize}

This function is used to open the serial port and set the data
transmission rate. \textbf{Syntax} \texttt{Serial.begin(speed);}
\textbf{Parameters} \texttt{Serial}: Serial port object. \texttt{speed}:
Baud rate, commonly set to values like 9600, 115200, etc.

\begin{itemize}
\tightlist
\item
  \texttt{**Serial.println();**}
\end{itemize}

\textbf{Syntax} \texttt{Serial.println(val);} \textbf{Parameters}
\texttt{Serial}: Serial port object. \texttt{val}: The value to be
printed, which can be of any data type.

For example, to print ``hello world!!!'' to the Serial Monitor, we need
to initialize the serial port in the \texttt{setup()} function and
output ``hello world!!!'' through the serial port in the \texttt{loop()}
function:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);} \CommentTok{// Initialize the serial port and set the data transmission rate to 9600}
\OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"hello world!!!"}\OperatorTok{);} \CommentTok{// Output "hello world!!!" through the serial port}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Returning to the question at the beginning of this section: when we have
written the code and verified it to be correct, but the effect of
running the code exceeds expectations or the hardware doesn't respond at
all, where is the problem? At this time, we can use the Serial Monitor
to observe the data sent or received by the hardware to make a judgment.
For instance, we can control the on-off state of an LED with a button,
and we can use the Serial Monitor to check the returned value when the
button is pressed to determine whether the button is working properly.
Next, we will learn how to use the Serial Monitor to make the hardware
``speak''. \#\# 1.4.2 Task 1: Use the Serial Monitor to Check if the
Button is Pressed \#\#\#\# Analysis Remember controlling the on-off
state of an LED with a button? Some of the code can be reused. We only
need to read the button on-off setting and button on-off state code, and
then add the initialization of the serial port and the data sent to the
serial port. The program writing still follows three steps:

\begin{itemize}
\tightlist
\item
  Define button pins and variables.
\item
  Initialize the serial port, set the serial port baud rate, and set the
  status of the button on-off pin.
\item
  Read the button state and send it to the serial port. \#\#\#\# Write
  the program \textbf{Step 1:} Define the button pin and variable.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ buttonPin }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// Define the button switch as pin 1. If you are using XIAO RP2040/XIAO ESP32, please change 1 to D1}
\DataTypeTok{int}\NormalTok{ buttonState }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// Define buttonState as a variable to store the button status}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Initialize the serial port, set the baud rate of the
serial port, and set the button switch pin status.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{,}\NormalTok{ INPUT\_PULLUP}\OperatorTok{);}  \CommentTok{// Set the button pin as input}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);} \CommentTok{// Initialize the serial port}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Read the button status and send it to the serial port

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    buttonState }\OperatorTok{=}\NormalTok{ digitalRead}\OperatorTok{(}\NormalTok{buttonPin}\OperatorTok{);}  \CommentTok{// Read the button status and store it in the buttonState variable}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{buttonState}\OperatorTok{);} \CommentTok{// Send the button status data to the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L4_ReadButton_XIAO_en}
\end{quote}

\hypertarget{upload-the-program}{%
\subsubsection*{Upload the program:}\label{upload-the-program}}
\addcontentsline{toc}{subsubsection}{Upload the program:}

We will upload the written program to the hardware. First, connect the
XIAO to the computer with the data cable from the kit.
\includegraphics{index_files/mediabag/1684977221668-62259e.jpeg} Note
the position of the buttons on the XIAO extensions used for testing in
the figure.

Click
\includegraphics{index_files/mediabag/1674004781256-2ef9b21234.png-averageHue=-5e999d-clientId=u44ac5a}
(Verify Button) in the Arduino IDE to verify the program. If the
verification is correct, click
\includegraphics{index_files/mediabag/1674004809585-a884271234.png-averageHue=-5c979b-clientId=u44ac5a}(Upload
Button) to upload the program to XIAO. When the debug area shows ``Done
uploading.'', open the serial monitor and observe the value changes
printed by the serial monitor when the button is pressed and released.
What did you find?

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/1684979740759-7ec42f.jpeg}

}

\end{figure}

When we press the button on the XIAO expansion board, the serial monitor
shows \texttt{0}, and when we release the button, the serial monitor
shows \texttt{1}. \#\# 1.4.3 Task 2: Using the Serial Monitor to View
Knob Value Changes \#\#\#\# Analysis: In Task 1, the button switch is a
digital input that sends out digital signals 0 and 1, while the knob
potentiometer returns an analog signal. We need to read the rotation
angle value of the knob potentiometer on pin \texttt{A0} and send it to
the serial port. The program also consists of three steps:

\begin{itemize}
\tightlist
\item
  Define the knob potentiometer pin and variables.
\item
  Initialize the serial port and set the status of the knob
  potentiometer pin.
\item
  Read and calculate the rotation angle value of the knob potentiometer
  and send it to the serial port. \#\#\#\# Write the program
  \textbf{Step 1:} Define the knob potentiometer pin and variables. Here
  we need to define the voltage value of the ADC (Analog-to-Digital
  Converter) and the reference voltage of the Grove module interface,
  because we will calculate the voltage changes in the circuit where the
  knob switch is connected through these voltage values.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{  }\CommentTok{// Define the rotary potentiometer interface A0}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// ADC reference voltage is 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// Grove interface reference voltage is 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{// The maximum rotation angle of the knob potentiometer is 300¬∞}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Initialize the serial port, set the baud rate of the
serial port, and set the status of the knob potentiometer pin.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);}\CommentTok{//Initialize the serial port}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);}\CommentTok{//Set the rotary potentiometer pin to input state}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Read and calculate the rotational angle value of the
rotary potentiometer and send it to the serial port. Here, we first need
to set the data type of the voltage variable, set the analog value
variable of the rotary potentiometer pin, and then calculate the
real-time voltage. After calculating the real-time voltage, calculate
the rotational angle value of the rotary potentiometer.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()}
\OperatorTok{\{}   
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;}    \CommentTok{//Variable voltage is of floating{-}point type}
    \DataTypeTok{int}\NormalTok{ sensorValue }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);}    \CommentTok{//Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensorValue}\OperatorTok{*}\NormalTok{ADC\_REF}\OperatorTok{/}\DecValTok{1023}\OperatorTok{;}    \CommentTok{//Calculate real{-}time voltage}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage}\OperatorTok{*}\NormalTok{FULL\_ANGLE}\OperatorTok{)/}\NormalTok{GROVE\_VCC}\OperatorTok{;}    \CommentTok{//Calculate the rotation angle of the knob}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);}    \CommentTok{//Print characters at the serial port}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);}    \CommentTok{//Print the rotation angle value of the rotary potentiometer at the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\hypertarget{define-macro-definition}{%
\subsection*{\texorpdfstring{\texttt{\#define} Macro
Definition}{\#define Macro Definition}}\label{define-macro-definition}}
\addcontentsline{toc}{subsection}{\texttt{\#define} Macro Definition}

\texttt{\#define} is a pre-processing command used for macro
definitions. In Arduino, we can use \texttt{\#define} to name constants.
During the compilation of the program, all occurrences of the ``macro
name'' will be replaced with the string in the macro definition, such as
\texttt{\#define\ ledPin\ 5}. During compilation, 5 will replace all
uses of \texttt{ledPin}. Syntax:
\texttt{\#define\ constant\ name\ constant\ value}. The ``\#'' symbol is
mandatory, and there is no need to use the ``;'' symbol at the end of
the sentence.
\end{quote}

The complete code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{ * Use the serial monitor to view the knob potentiometer}
\CommentTok{ */}
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\CommentTok{//Define the rotary potentiometer interface A0}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//ADC reference voltage 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//Reference voltage 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{//The maximum rotation angle of the rotary potentiometer is 300¬∞}
 
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);}\CommentTok{//Initialize the serial port}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);}\CommentTok{//Set the rotary potentiometer pin as an input}
\OperatorTok{\}}
 
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()}
\OperatorTok{\{}   
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;}\CommentTok{//Variable voltage is of floating{-}point type}
    \DataTypeTok{int}\NormalTok{ sensorValue }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);}\CommentTok{//Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensorValue}\OperatorTok{*}\NormalTok{ADC\_REF}\OperatorTok{/}\DecValTok{1023}\OperatorTok{;}\CommentTok{//Calculate real{-}time voltage}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage}\OperatorTok{*}\NormalTok{FULL\_ANGLE}\OperatorTok{)/}\NormalTok{GROVE\_VCC}\OperatorTok{;}\CommentTok{//Calculate the rotation angle of the knob}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);}\CommentTok{//Print characters at the serial port}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);}\CommentTok{//Print the rotation angle value of the rotary potentiometer at the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L4_ReadRotary_XIAO_en}
\end{quote}

\hypertarget{upload-the-program-1}{%
\subsubsection*{Upload the program:}\label{upload-the-program-1}}
\addcontentsline{toc}{subsubsection}{Upload the program:}

After writing the program, since external sensors are used, connect the
knob module to the \texttt{A0} interface using the four-color Grove
cable as shown in the image below:
\includegraphics{index_files/mediabag/1615960111957-ae4735.png-averageHue=-bdbab6-height=424-id=Sq}
After connecting, connect the XIAO main control board to your computer
using a data cable. In the Arduino IDE, click on the verification button
\includegraphics{index_files/mediabag/1674004781256-2ef9b212345.png-averageHue=-5e999d-clientId=u44ac5a}
to verify the program. If it verifies correctly, click the upload button
to upload the program
to\includegraphics{index_files/mediabag/1674004809585-a8842712345.png-averageHue=-5c979b-clientId=u44ac5a}
the hardware. When the debugging area shows ``Done uploading.'', you can
proceed. Open the serial monitor and rotate the knob potentiometer to
observe the data changes displayed in the serial monitor. These changes
represent the angle value of the knob.
\includegraphics{index_files/mediabag/1684979680733-1fe3ce.jpeg} \#\#
1.4.4 Extended Exercise While observing the angle value of the knob
potentiometer in the serial monitor, we find that the value is
constantly jumping and changing. Observing through the numbers alone is
not very intuitive. At this time, we can use the serial plotter. With
it, we can plot the data that is printed to the Arduino's serial port in
real time. Based on the second task, close the serial monitor and open
the \textbf{``Tools ‚Üí Serial Plotter''} as shown in the image below:
\includegraphics{index_files/mediabag/1684979746835-ffab0b.jpeg} The
serial plotter draws the data obtained from the serial port into an XY
axis curve chart, where the X-axis represents the change in time and the
Y-axis represents the data obtained from the serial port. Through the
chart, you can more intuitively see the change in data. Please give it a
try.

\bookmarksetup{startatroot}

\hypertarget{controlling-led-and-servo-with-a-knob}{%
\chapter*{1.5 Controlling LED and Servo with a
Knob}\label{controlling-led-and-servo-with-a-knob}}
\addcontentsline{toc}{chapter}{1.5 Controlling LED and Servo with a
Knob}

\markboth{1.5 Controlling LED and Servo with a Knob}{1.5 Controlling LED
and Servo with a Knob}

In the last section, we learned how to use the serial monitor and
observed the differences between digital input and analog input through
it. In this section, we will further explore the use of analog values by
combining them with a rotary potentiometer! \#\# 1.5.1 Background
Knowledge \#\#\# 1.5.1.1 Servo and Servo Library \#\#\#\# Servo
\includegraphics{index_files/mediabag/1613486221628-4feeb2.png-averageHue=-e3e3de-height=170-id=bA}
A servo, also known as a servo motor, is a DC motor with gears and a
feedback system. We can control the servo to rotate to a specific
angular position by sending signals to the circuit. This makes it
suitable for electronic devices or robots that require precise position
control. \#\#\#\# Servo Library servo.h When we want to control a servo
using XIAO or other Arduino development boards, we can use the servo.h
library file. It's one of the Arduino standard libraries, which is
convenient to use and also avoids the problem of limited PWM pin
quantity. Here are the relevant functions of the servo library:

\begin{itemize}
\tightlist
\item
  Declare the library file
\end{itemize}

\texttt{\#include\ \textless{}Servo.h\textgreater{}}

\begin{itemize}
\tightlist
\item
  Create the \texttt{myservo} object to control the servo
\end{itemize}

\texttt{Servo\ myservo;}

\begin{itemize}
\tightlist
\item
  Use the \texttt{attach()} function to call the signal pin
\end{itemize}

\texttt{myservo.attach();}

\begin{itemize}
\tightlist
\item
  Use the \texttt{write()} function to write the angle to the servo,
  setting the rotation angle of the shaft
\end{itemize}

\texttt{myservo.write();}

The servo library does not need to be manually installed. You can open
the example program \textbf{``File ‚Üí Examples ‚Üí Servo''} and check the
two example programs ``Knob'' and ``Sweep'' to familiarize yourself with
the use of the servo library.
\includegraphics{index_files/mediabag/1684997950475-c430bc.jpeg} If you
can't find Servo under Examples, you can visit
\url{https://github.com/arduino-libraries/Servo} and add the Servo
example by installing the library. \#\#\# 1.5.1.2 \texttt{map()}
Function The \texttt{map()} function is used to map a number from one
range to another. That is, \texttt{fromLow} gets mapped to
\texttt{toLow}, and \texttt{fromHigh} gets mapped to \texttt{toHigh}.
It's the simplest form of linear mapping. \textbf{Syntax}
\texttt{map(value,\ fromLow,\ fromHigh,\ toLow,\ toHigh)}

\textbf{Parameters} \texttt{value}: The number to be mapped.
\texttt{fromLow}: The lower limit of the current range of the value.
\texttt{fromHigh}: The upper limit of the current range of the value.
\texttt{toLow}: The lower limit of the target range of the value.
\texttt{toHigh}: The upper limit of the target range of the value.

\textbf{Example: Map} \texttt{**val**}** from the range 0-1023 to
0-255.**

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{\}}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ val }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\DecValTok{0}\OperatorTok{);} \CommentTok{// read the value from analog pin A0}
\NormalTok{    val }\OperatorTok{=}\NormalTok{ map}\OperatorTok{(}\NormalTok{val}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{1023}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{255}\OperatorTok{);} \CommentTok{// map val to the range 0{-}255}
\NormalTok{    analogWrite}\OperatorTok{(}\DecValTok{9}\OperatorTok{,}\NormalTok{ val}\OperatorTok{);} \CommentTok{// output the analog value to pin 9}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{task-1-using-a-knob-potentiometer-to-control-the-brightness-of-the-onboard-led-on-the-xiao-board}{%
\section*{1.5.2 Task 1: Using a knob potentiometer to control the
brightness of the onboard LED on the XIAO
board}\label{task-1-using-a-knob-potentiometer-to-control-the-brightness-of-the-onboard-led-on-the-xiao-board}}
\addcontentsline{toc}{section}{1.5.2 Task 1: Using a knob potentiometer
to control the brightness of the onboard LED on the XIAO board}

\markright{1.5.2 Task 1: Using a knob potentiometer to control the
brightness of the onboard LED on the XIAO board}

\hypertarget{analysis}{%
\subsubsection*{Analysis:}\label{analysis}}
\addcontentsline{toc}{subsubsection}{Analysis:}

When using a knob potentiometer to control the LED, we need to use the
map() function, because the analog value directly output by the knob
potentiometer is 0-1023, this value is not the angle value of the knob
rotation, we need to calculate the angle value of the knob potentiometer
rotation first, then map this value to the brightness range of the LED
0-255 with the map() function. The steps to write the program are as
follows:

\begin{itemize}
\tightlist
\item
  Define the knob potentiometer, LED pin.
\item
  Initialize the serial port, set the status of the knob potentiometer
  and LED pin.
\item
  Read and calculate the rotation angle value of the knob potentiometer,
  and send it to the serial port.
\item
  Map the angle value of the knob potentiometer to the LED brightness
  value and store it in the brightness variable, and the LED outputs
  this variable value. \#\#\#\# Writing the program: \textbf{Step 1:}
  Define the knob potentiometer, LED pin, here we need to define ADC and
  VCC reference voltage, in order to calculate the angle value of the
  knob potentiometer.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{ }\CommentTok{//Define rotary potentiometer interface A0}
\PreprocessorTok{\#define LEDPIN }\DecValTok{13}\PreprocessorTok{ }\CommentTok{//Define LED interface 13}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//Reference voltage 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//GROVE reference voltage 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{//The maximum rotation angle of the rotary potentiometer is 300¬∞}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Initialize the serial port, set the status of the knob
potentiometer and LED pin.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);} \CommentTok{//Initialize serial communication}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);} \CommentTok{//Set the rotary potentiometer pin to input}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{OUTPUT}\OperatorTok{);} \CommentTok{//Set the LED pin to output }
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Read and calculate the rotation angle value of the knob
potentiometer, and send it to the serial port.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()}
\OperatorTok{\{}   
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;} \CommentTok{//Variable voltage of type float}
    \DataTypeTok{int}\NormalTok{ sensor\_value }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);} \CommentTok{//Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensor\_value}\OperatorTok{*}\NormalTok{ADC\_REF}\OperatorTok{/}\DecValTok{1023}\OperatorTok{;} \CommentTok{//Calculate the real{-}time voltage}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage}\OperatorTok{*}\NormalTok{FULL\_ANGLE}\OperatorTok{)/}\NormalTok{GROVE\_VCC}\OperatorTok{;} \CommentTok{//Calculate the angle of rotation of the knob}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);} \CommentTok{//Print character on serial monitor}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);} \CommentTok{//Print the rotation angle value of the rotary potentiometer on the serial monitor}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Step 4:} Map the angle value of the knob potentiometer to the
LED brightness value and store it in the brightness variable, and the
LED outputs this variable value.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//After Step 3}
    \DataTypeTok{int}\NormalTok{ brightness}\OperatorTok{;} \CommentTok{//Define brightness variable}
\NormalTok{    brightness }\OperatorTok{=}\NormalTok{ map}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ FULL\_ANGLE}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{255}\OperatorTok{);} \CommentTok{//Map the rotation angle value of the rotary potentiometer to the brightness value of the LED and store it in the brightness variable}
\NormalTok{    analogWrite}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{brightness}\OperatorTok{);} \CommentTok{//Output the variable value to the LED}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The final complete code is shown below:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{ }\CommentTok{//Define rotary potentiometer interface A0}
\PreprocessorTok{\#define LEDPIN }\DecValTok{13}\PreprocessorTok{ }\CommentTok{//Define LED interface 13}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//Reference voltage 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{//GROVE reference voltage 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{//The maximum rotation angle of the rotary potentiometer is 300¬∞}
 
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);} \CommentTok{//Initialize serial communication}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);} \CommentTok{//Set the rotary potentiometer pin to input}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{OUTPUT}\OperatorTok{);} \CommentTok{//Set the LED pin to output }
\OperatorTok{\}}
 
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()}
\OperatorTok{\{}   
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;} \CommentTok{//Variable voltage of type float}
    \DataTypeTok{int}\NormalTok{ sensor\_value }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);} \CommentTok{//Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensor\_value}\OperatorTok{*}\NormalTok{ADC\_REF}\OperatorTok{/}\DecValTok{1023}\OperatorTok{;} \CommentTok{//Calculate the real{-}time voltage}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage}\OperatorTok{*}\NormalTok{FULL\_ANGLE}\OperatorTok{)/}\NormalTok{GROVE\_VCC}\OperatorTok{;} \CommentTok{//Calculate the angle of rotation of the knob}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);} \CommentTok{//Print character on serial monitor}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);} \CommentTok{//Print the rotation angle value of the rotary potentiometer on the serial monitor}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
    
    \DataTypeTok{int}\NormalTok{ brightness}\OperatorTok{;} \CommentTok{//Define brightness variable}
\NormalTok{    brightness }\OperatorTok{=}\NormalTok{ map}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ FULL\_ANGLE}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{255}\OperatorTok{);} \CommentTok{//Map the rotation angle value of the rotary potentiometer to the brightness value of the LED and store it in the brightness variable}
\NormalTok{    analogWrite}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{brightness}\OperatorTok{);} \CommentTok{//Output the variable value to the LED}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L5_RotaryLed_XIAO_en}
\end{quote}

\hypertarget{uploading-the-program-3}{%
\subsubsection*{Uploading the Program:}\label{uploading-the-program-3}}
\addcontentsline{toc}{subsubsection}{Uploading the Program:}

After writing the program, connect the rotary potentiometer to the
\texttt{A0} interface using a four-color Grove wire, as shown in the
following figure:
\includegraphics{index_files/mediabag/1616058445509-71340a.png-averageHue=-a6a4a0-height=420-id=pF}
Connect the XIAO main control board to your computer with a data cable.
After connecting, click
\includegraphics{index_files/mediabag/1674004781256-2ef9b2123456.png-averageHue=-5e999d-clientId=u44ac5a}
(the verify button) in the Arduino IDE to check the program. If there
are no errors, click
\includegraphics{index_files/mediabag/1674004809585-a88427123456.png-averageHue=-5c979b-clientId=u44ac5a}
(the upload button) to upload the program to the hardware. When the
debug area shows ``Done uploading.'', you can open the serial monitor to
observe the rotation angle and LED brightness values as you rotate the
potentiometer.
\includegraphics{index_files/mediabag/1669278548855-2d9ad0.jpeg-averageHue=-a2937e-clientId=u63953}
\textgreater{} ‚ö†Ô∏è Note The onboard LED of the XIAO board is used in this
example.

If you need to operate offline, you can connect a lithium battery to the
expansion board, as shown in the following figure.
\includegraphics{index_files/mediabag/1616918339465-aa2fe9.jpeg-averageHue=-faf9f8-height=2320-id=}
\#\#\# Controlling an External LED with a Knob on the XIAO ESP32C3 The
Seeed XIAO ESP32C3 does not have an onboard LED for users. To run this
program, you need to first connect an LED to the \texttt{D10} pin of the
board, as shown below:
\includegraphics{index_files/mediabag/1666778092446-9a6e7212.png-averageHue=-d8d4cb-clientId=u5d6c62}
\textgreater{} ‚ö†Ô∏è Note Be sure to connect a resistor (about 150Œ©) in
series with the LED to limit the current passing through the LED and
prevent it from being damaged by overcurrent.

Next, copy the following program into the Arduino IDE:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{ }\CommentTok{// Define rotary potentiometer interface A0}
\PreprocessorTok{\#define LEDPIN }\NormalTok{D10}\PreprocessorTok{ }\CommentTok{// Define LED light interface 10}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// Reference voltage 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// GROVE reference voltage 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{// The maximum rotation angle of the rotary potentiometer is 300¬∞}

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);} \CommentTok{// Initialize serial communication}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);} \CommentTok{// Set the rotary potentiometer pin to input mode}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);} \CommentTok{// Set the LED light pin to output mode }
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()}
\OperatorTok{\{}   
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;} \CommentTok{// Define voltage variable as float}
    \DataTypeTok{int}\NormalTok{ sensor\_value }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);} \CommentTok{// Read the analog value on the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensor\_value}\OperatorTok{*}\NormalTok{ADC\_REF}\OperatorTok{/}\DecValTok{1023}\OperatorTok{;} \CommentTok{// Calculate real{-}time voltage}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage}\OperatorTok{*}\NormalTok{FULL\_ANGLE}\OperatorTok{)/}\NormalTok{GROVE\_VCC}\OperatorTok{;} \CommentTok{// Calculate the angle of rotation of the knob}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);} \CommentTok{// Print string to serial port}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);} \CommentTok{// Print the rotation angle value of the rotary potentiometer to the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}

    \DataTypeTok{int}\NormalTok{ brightness}\OperatorTok{;} \CommentTok{// Define brightness variable}
\NormalTok{    brightness }\OperatorTok{=}\NormalTok{ map}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ FULL\_ANGLE}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{255}\OperatorTok{);} \CommentTok{// Map the rotary potentiometer angle value to LED light brightness value and store it in the brightness variable}
\NormalTok{    analogWrite}\OperatorTok{(}\NormalTok{LEDPIN}\OperatorTok{,}\NormalTok{ brightness}\OperatorTok{);} \CommentTok{// Output brightness value to LED light}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{500}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L5_RotaryLed_XIAO_ESP32C3_en}
\end{quote}

\hypertarget{task-2-control-a-servo-motor-with-a-rotary-potentiometer}{%
\section*{1.5.3 Task 2: Control a Servo Motor with a Rotary
Potentiometer}\label{task-2-control-a-servo-motor-with-a-rotary-potentiometer}}
\addcontentsline{toc}{section}{1.5.3 Task 2: Control a Servo Motor with
a Rotary Potentiometer}

\markright{1.5.3 Task 2: Control a Servo Motor with a Rotary
Potentiometer}

\hypertarget{analysis-1}{%
\subsubsection*{Analysis}\label{analysis-1}}
\addcontentsline{toc}{subsubsection}{Analysis}

When controlling a servo motor with a rotary potentiometer, we can use
the \texttt{servo.h} library and modify our first task slightly. The
program can be divided into the following steps:

\begin{itemize}
\tightlist
\item
  Declare the servo library, define the servo rotation angle variable,
  define the rotary potentiometer pin and voltage.
\item
  Initialize the serial port, set the status of the rotary potentiometer
  and servo pins.
\item
  Read and calculate the rotation angle value of the rotary
  potentiometer, send it to the serial port, and drive the servo to
  rotate according to the angle value change. \#\#\#\# Program Writing
  \textbf{Step 1:} Declare the servo library, define the servo rotation
  angle variable, define the rotary potentiometer pin and voltage.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Servo.h\textgreater{}}\CommentTok{// Declare the use of the servo library}
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{ }\CommentTok{// Define the rotary potentiometer pin as A0}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// ADC reference voltage is 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// GROVE module reference voltage is 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{// The maximum rotation angle of the rotary potentiometer is 300¬∞}
\NormalTok{Servo myservo}\OperatorTok{;}  \CommentTok{// Create a myservo object to control the servo}
\DataTypeTok{int}\NormalTok{ pos }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// Variable to store the rotation angle of the servo}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Initialize the serial port, set the status of the
rotary potentiometer and servo pins.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);}\CommentTok{// Initialize the serial port}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);}\CommentTok{// Set the rotary potentiometer pin as input}
\NormalTok{    myservo}\OperatorTok{.}\NormalTok{attach}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}  \CommentTok{// The myservo signal is transmitted through pin 5, if you are using XIAO RP2040/XIAO ESP32, please modify 5 to D5}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Read and calculate the rotation angle value of the
rotary potentiometer, send it to the serial port, and drive the servo to
rotate according to the angle value change.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;}\CommentTok{// Set voltage as a floating point}
    \DataTypeTok{int}\NormalTok{ sensor\_value }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);}\CommentTok{// Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensor\_value }\OperatorTok{*}\NormalTok{ ADC\_REF }\OperatorTok{/} \DecValTok{1023}\OperatorTok{;}\CommentTok{// Real{-}time voltage is the read analog value multiplied by the reference voltage divided by 1023}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage }\OperatorTok{*}\NormalTok{ FULL\_ANGLE}\OperatorTok{)} \OperatorTok{/}\NormalTok{ GROVE\_VCC}\OperatorTok{;}\CommentTok{// The rotation angle of the knob is the real{-}time voltage multiplied by the maximum rotation angle of the rotary potentiometer divided by the voltage value of the GROVE module interface}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);}\CommentTok{// Print characters on the serial port}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);}\CommentTok{// Print the rotation angle value of the rotary potentiometer on the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{50}\OperatorTok{);}
\NormalTok{    myservo}\OperatorTok{.}\NormalTok{write}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);} \CommentTok{// Write the rotation angle value of the rotary potentiometer into the servo}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The final code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Servo.h\textgreater{}}\CommentTok{// Declare the use of the servo library}
\PreprocessorTok{\#define ROTARY\_ANGLE\_SENSOR }\NormalTok{A0}\PreprocessorTok{ }\CommentTok{// Define the rotary potentiometer pin as A0}
\PreprocessorTok{\#define ADC\_REF }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// ADC reference voltage is 3V}
\PreprocessorTok{\#define GROVE\_VCC }\DecValTok{3}\PreprocessorTok{ }\CommentTok{// GROVE module reference voltage is 3V}
\PreprocessorTok{\#define FULL\_ANGLE }\DecValTok{300}\PreprocessorTok{ }\CommentTok{// The maximum rotation angle of the rotary potentiometer is 300¬∞}
\NormalTok{Servo myservo}\OperatorTok{;}  \CommentTok{// Create a myservo object to control the servo}
\DataTypeTok{int}\NormalTok{ pos }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// Variable to store the rotation angle of the servo}

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{begin}\OperatorTok{(}\DecValTok{9600}\OperatorTok{);}\CommentTok{// Initialize the serial port}
\NormalTok{    pinMode}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{,}\NormalTok{ INPUT}\OperatorTok{);}\CommentTok{// Set the rotary potentiometer pin as input}
\NormalTok{    myservo}\OperatorTok{.}\NormalTok{attach}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}  \CommentTok{// The myservo signal is transmitted through pin 5, if you are using XIAO RP2040/XIAO ESP32, please modify 5 to D5}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ voltage}\OperatorTok{;}\CommentTok{// Set voltage as a floating point}
    \DataTypeTok{int}\NormalTok{ sensor\_value }\OperatorTok{=}\NormalTok{ analogRead}\OperatorTok{(}\NormalTok{ROTARY\_ANGLE\_SENSOR}\OperatorTok{);}\CommentTok{// Read the analog value at the rotary potentiometer pin}
\NormalTok{    voltage }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{sensor\_value }\OperatorTok{*}\NormalTok{ ADC\_REF }\OperatorTok{/} \DecValTok{1023}\OperatorTok{;}\CommentTok{// Real{-}time voltage is the read analog value multiplied by the reference voltage divided by 1023}
    \DataTypeTok{float}\NormalTok{ degrees }\OperatorTok{=} \OperatorTok{(}\NormalTok{voltage }\OperatorTok{*}\NormalTok{ FULL\_ANGLE}\OperatorTok{)} \OperatorTok{/}\NormalTok{ GROVE\_VCC}\OperatorTok{;}\CommentTok{// The rotation angle of the knob is the real{-}time voltage multiplied by the maximum rotation angle of the rotary potentiometer divided by the voltage value of the GROVE module interface}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\StringTok{"The angle between the mark and the starting position:"}\OperatorTok{);}\CommentTok{// Print characters on the serial port}
\NormalTok{    Serial}\OperatorTok{.}\NormalTok{println}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);}\CommentTok{// Print the rotation angle value of the rotary potentiometer on the serial port}
\NormalTok{    delay}\OperatorTok{(}\DecValTok{50}\OperatorTok{);}
\NormalTok{    myservo}\OperatorTok{.}\NormalTok{write}\OperatorTok{(}\NormalTok{degrees}\OperatorTok{);} \CommentTok{// Write the rotation angle value of the rotary potentiometer into the servo}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L5_RotaryServo_XIAO_en}
\end{quote}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{upload-program}{%
\subsubsection*{Upload Program}\label{upload-program}}
\addcontentsline{toc}{subsubsection}{Upload Program}

After writing the program, first connect the knob potentiometer and the
servo to the XIAO expansion board as shown in the figure below. Then,
connect the XIAO main control board to the computer with a data cable.
\includegraphics{index_files/mediabag/1615961383454-c13764.png-averageHue=-cfcbc6-height=800-id=NY}

After the connection, click
\includegraphics{index_files/mediabag/1674004781256-2ef9b21234567.png-averageHue=-5e999d-clientId=u44ac5a}(the
verify button) in the Arduino IDE to verify the program. If the
verification is error-free, click
\includegraphics{index_files/mediabag/1674004809585-a884271234567.png-averageHue=-5c979b-clientId=u44ac5a}(the
upload button) to upload the program to the hardware. When the debugging
area shows ``Done uploading.'', you can open the serial monitor, rotate
the knob potentiometer, and observe the changes in angle value and the
movement of the servo. What have you found?
\includegraphics{index_files/mediabag/1616920615726-feefed.jpeg-averageHue=-f8f7f5-height=407-id=d}
\textgreater{} \textbf{‚ö†Ô∏è Note:} The rotation range of the servo is
0¬∞-180¬∞, so you will see in the serial monitor that when the angle value
is greater than 180¬∞, the servo stops rotating.

\hypertarget{extended-exercise-2}{%
\section*{1.5.4 Extended Exercise}\label{extended-exercise-2}}
\addcontentsline{toc}{section}{1.5.4 Extended Exercise}

\markright{1.5.4 Extended Exercise}

We have been using the LED on the XIAO board. If I want to use an
external LED and control it with a knob potentiometer to create a
breathing light effect, what should I do? The XIAO expansion board
brings out two digital-analog Grove interfaces, and there is an
\texttt{A7/D7} interface. We can connect the external LED to this
interface, as shown in the figure:
\includegraphics{index_files/mediabag/1616391747619-d3b499.png-averageHue=-cdc8c2-height=449-id=YU}
After the connection, we can slightly modify the program from Task 1,
changing \texttt{\#define\ LEDPIN\ 13} to \texttt{\#define\ LEDPIN\ 7}.
Upload the modified program and see if it can achieve our desired
effect. \textgreater{} Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L5_RotaryLed_ledmodule_en}

\bookmarksetup{startatroot}

\hypertarget{displaying-hello-world-on-oled}{%
\chapter*{1.6 Displaying ``Hello World'' on
OLED}\label{displaying-hello-world-on-oled}}
\addcontentsline{toc}{chapter}{1.6 Displaying ``Hello World'' on OLED}

\markboth{1.6 Displaying ``Hello World'' on OLED}{1.6 Displaying ``Hello
World'' on OLED}

In our daily life, we see displays everywhere - televisions, computers,
phones, car displays, LCD billboards in shopping malls\ldots{} Without a
variety of screens, our lives would lose much of its fun. Of course,
these screens, besides leisure and entertainment, are also indispensable
tools for daily life. Common displays include LCD displays, OLED
displays, etc. They all have their own strengths and weaknesses as
display devices and can be applied in different fields and scenarios.
The XIAO expansion board integrates an OLED display. In this lesson, we
will learn how to use OLED to display text, patterns, and images. \#\#
1.6.1 Background Knowledge \#\#\# 1.6.1.1 OLED Display OLED, also known
as Organic Light Emitting Diode, has advantages such as self-luminous,
low power consumption, fast response speed, high resolution, light
weight, etc. Its application field is very wide. The XIAO expansion
board integrates a 0.96 inch 128x64 pixel OLED display, which can be
used directly without wiring. During project production, we can display
time, temperature and humidity, and other sensor return values through
the OLED display, and we can also directly display letters, numbers,
graphics, and even patterns, achieving visual interactive effects.
\includegraphics{index_files/mediabag/1615276959688-448f39.png-averageHue=-545454-height=169-id=lN}
\#\#\# 1.6.1.2 How to Download and Install the U8g2\_Arduino Library A
library is a collection of program codes, which encapsulates some
commonly used functions into a file for users to call. When we use OLED
displays, temperature and humidity sensors, etc., we need to use the
corresponding libraries. Where can these libraries be downloaded and how
to install them? We will explain using the U8g2\_Arduino library file of
the OLED display as an example. Enter the website link üîó
\url{https://github.com/olikraus/u8g2_arduino} to enter the GitHub page,
click Code‚ÜíDownload ZIP to download the resource package to the local,
as shown in the figure below.
\includegraphics{index_files/mediabag/1669095424276-2c8bcf.jpeg} After
the download is complete, open the Arduino IDE, click Sketch‚ÜíInclude
Library‚ÜíAdd .ZIP Library, and select the ZIP file you just downloaded.
\includegraphics{index_files/mediabag/1685001646302-9aacd3.5-rotation=0-showTitle=false-size=53175}
If the library is installed correctly, you can see the prompt
information for successful library installation in the output window.
\#\#\# 1.6.1.3 U8g2 Library for OLED
\includegraphics{index_files/mediabag/1615968476586-5d2f51.jpeg-averageHue=-f07d16-height=224-id=d}
U8g2 is a monochrome graphics library for embedded devices, which
supports various types of OLED displays, making it easy for us to write
programs to achieve the desired effects. The U8g2 library also includes
the U8x8 library, and the two libraries have different functions:
\#\#\#\# U8g2 Includes all graphic procedures (line/box/circle drawing);
Supports various fonts, (almost) no restrictions on font height; Some
memory in the microcontroller is needed to display. \#\#\#\# U8x8 Only
supports text (character) output; Only allows each character to use a
fixed-size font (8x8 pixels); Writes directly to the display, no buffer
is needed in the microcontroller. Simply put, when we want the OLED
display to display various fonts, graphics, patterns, and present visual
content more flexibly, we can use the U8g2 library; when we want to
display characters more directly, with no font requirements, just to
display sensor values, time, etc., we can use the U8x8 library, which is
more efficient. We can find many example programs in
``File‚ÜíExamples‚ÜíU8g2'', and familiarize ourselves with the use of the
library through the example programs.
\includegraphics{index_files/mediabag/1685004995329-4b8579.jpeg} Next,
we will display characters and draw circles using two libraries
respectively. \#\# 1.6.2 Task 1: Display Hello World! on the OLED of the
XIAO expansion board \textgreater{} ‚ö†Ô∏è Note Before starting to write a
program for the OLED of the XIAO expansion board, make sure the Arduino
IDE has loaded the \texttt{U8g2\_Arduino} library file. The loading
method can be referred to the description in the ``How to Download and
Install Arduino Library'' section of this lesson.

\hypertarget{analysis-2}{%
\subsubsection*{Analysis}\label{analysis-2}}
\addcontentsline{toc}{subsubsection}{Analysis}

If you just want to display ``Hello World!'' on the OLED, you can
directly write characters with the U8x8 library. The steps are as
follows:

\begin{itemize}
\tightlist
\item
  Declare the library file, set the constructor, and the constructor
  defines the display type, controller, RAM buffer size, and
  communication protocol.
\item
  Initialize the display.
\item
  Set the display font, set the print starting position, and output
  ``Hello World!''. \#\#\#\# Write the program \textbf{Step 1:} Declare
  the library file, set the constructor, and the constructor defines the
  display type, controller, RAM buffer size, and communication protocol.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Arduino.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}U8x8lib.h\textgreater{}}\CommentTok{//Use U8x8 library file}
\NormalTok{U8X8\_SSD1306\_128X64\_NONAME\_HW\_I2C u8x8}\OperatorTok{(}\CommentTok{/* reset=*/}\NormalTok{ U8X8\_PIN\_NONE}\OperatorTok{);}
\CommentTok{//Set the constructor, define the display type, controller, RAM buffer size, and communication protocol, generally determine according to the used display model}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} Initialize the display. After declaring the library
file in the previous step, you can use the functions in the library to
set the OLED display.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{begin}\OperatorTok{();}\CommentTok{//Initialize u8x8 library}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setFlipMode}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}\CommentTok{//Flip the display 180 degrees, generally numbers 0 and 1}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Set the display font (there are various fonts to choose
from in the u8x8 library, we can refer to
\url{https://github.com/olikraus/u8g2/wiki/fntlist8x8} to choose), set
the print starting position, and output ``Hello World!''.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setFont}\OperatorTok{(}\NormalTok{u8x8\_font\_chroma48medium8\_r}\OperatorTok{);}\CommentTok{//Define u8x8 font}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setCursor}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}\CommentTok{//Set the position of the drawing cursor}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{print}\OperatorTok{(}\StringTok{"Hello World!"}\OperatorTok{);}\CommentTok{//Draw content on OLED: Hello WorldÔºÅ}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The complete program is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Arduino.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}U8x8lib.h\textgreater{}}\CommentTok{//Use U8x8 library file}
\NormalTok{U8X8\_SSD1306\_128X64\_NONAME\_HW\_I2C u8x8}\OperatorTok{(}\CommentTok{/* reset=*/}\NormalTok{ U8X8\_PIN\_NONE}\OperatorTok{);}
\CommentTok{//Set the constructor, define the display type, controller, RAM buffer size, and communication protocol, generally determine according to the used display model}

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{begin}\OperatorTok{();}\CommentTok{//Initialize u8x8 library}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setFlipMode}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}\CommentTok{//Flip the display 180 degrees, generally numbers 0 and 1}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setFont}\OperatorTok{(}\NormalTok{u8x8\_font\_chroma48medium8\_r}\OperatorTok{);}\CommentTok{//Define u8x8 font}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{setCursor}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}\CommentTok{//Set the position of the drawing cursor}
\NormalTok{    u8x8}\OperatorTok{.}\NormalTok{print}\OperatorTok{(}\StringTok{"Hello World!"}\OperatorTok{);}\CommentTok{//Draw content on OLED: Hello WorldÔºÅ}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L6_HelloWorld_XIAO_en}
\end{quote}

\hypertarget{program-upload}{%
\subsubsection*{Program Upload:}\label{program-upload}}
\addcontentsline{toc}{subsubsection}{Program Upload:}

After the program is written, we connect the XIAO main control board to
the computer interface using a data cable, as shown in the image below:
\includegraphics{index_files/mediabag/1615972066074-7b4972.png-averageHue=-dddcdc-height=1073-id=C}
Click ``Upload'' to transfer the program to the main control board. Once
the upload is complete, check if the OLED display shows ``Hello
World!''.
\includegraphics{index_files/mediabag/1616922722229-2d7ff6.jpeg-averageHue=-b1afa5-height=393-id=O}
\#\# 1.6.3 Task 2: Draw a Circle on the OLED Display \#\#\#\# Analysis
To draw a circle on the OLED display, we need to use the \texttt{U8g2}
library. Programming involves four steps:

\begin{itemize}
\tightlist
\item
  Declare the \texttt{U8g2} library file, determine whether to use SPI
  or I2C protocol, and set up the constructor to connect to the OLED
  display.
\item
  The \texttt{draw()} function uses the \texttt{u8g2.drawCircle}
  function to draw a circle on the OLED.
\item
  Initialize the \texttt{U8g2} library.
\item
  In the \texttt{loop()} function, call related functions to draw images
  on the OLED. \#\#\#\# Program Writing \textbf{Step 1:} Declare the
  \texttt{U8g2} library file, determine whether to use SPI or I2C
  protocol, and set up the constructor to connect to the OLED display.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include}\ImportTok{\textless{}Arduino.h\textgreater{}}
\PreprocessorTok{\#include}\ImportTok{\textless{}U8g2lib.h\textgreater{}}\CommentTok{//Use U8g2 library}

\CommentTok{// Determine whether to use SPI or I2C protocol}
\PreprocessorTok{\#ifdef U8X8\_HAVE\_HW\_SPI}
\PreprocessorTok{\#include}\ImportTok{\textless{}SPI.h\textgreater{}}
\PreprocessorTok{\#endif}
\PreprocessorTok{\#ifdef U8X8\_HAVE\_HW\_I2C}
\PreprocessorTok{\#include}\ImportTok{\textless{}Wire.h\textgreater{}}
\PreprocessorTok{\#endif}

\NormalTok{U8G2\_SSD1306\_128X64\_NONAME\_F\_HW\_I2C u8g2}\OperatorTok{(}\NormalTok{U8G2\_R0}\OperatorTok{,} \CommentTok{/* reset=*/}\NormalTok{ U8X8\_PIN\_NONE}\OperatorTok{);}
\CommentTok{// Set up the constructor, define display type, controller, RAM buffer size, and communication protocol}
\end{Highlighting}
\end{Shaded}

\textbf{Step 2:} The \texttt{draw()}function uses the
\texttt{u8g2.drawCircle} function to draw a circle on the OLED. The
\texttt{u8g2.drawCircle(x0,y0,rad,opt)} function parameters are as
follows:

\begin{itemize}
\tightlist
\item
  \texttt{x0,y0}: The position of the center of the circle.
\item
  \texttt{rad}: Defines the size of the circle, with the diameter of the
  circle being 2*rad+1.
\item
  \texttt{opt}: Choose a part or all of the circle.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ draw}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} 
\NormalTok{    u8g2}\OperatorTok{.}\NormalTok{drawCircle}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{10}\OperatorTok{,}\NormalTok{ U8G2\_DRAW\_ALL}\OperatorTok{);}\CommentTok{// Draw a full circle with a diameter of 21 at coordinates (20, 25)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 3:} Initialize the \texttt{U8g2} library.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    u8g2}\OperatorTok{.}\NormalTok{begin}\OperatorTok{();}\CommentTok{// Initialize the library}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Step 4:} In the \texttt{loop()} function, call related functions
to draw images on the OLED. Use the firstPage and nextPage functions to
cycle through image content. They need to be used together, as shown in
the program below:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Cycle through image display}
\NormalTok{    u8g2}\OperatorTok{.}\NormalTok{firstPage}\OperatorTok{();}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        draw}\OperatorTok{();}\CommentTok{// Use draw function}
    \OperatorTok{\}} \ControlFlowTok{while}\OperatorTok{(}\NormalTok{ u8g2}\OperatorTok{.}\NormalTok{nextPage}\OperatorTok{()} \OperatorTok{);}

\NormalTok{    delay}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Get this program from Github
\url{https://github.com/mouseart/XIAO-Mastering-Arduino-and-TinyML/tree/main/code/L6_DrawCircle_XIAO_en}
\end{quote}

\hypertarget{uploading-the-program-4}{%
\subsubsection*{Uploading the Program}\label{uploading-the-program-4}}
\addcontentsline{toc}{subsubsection}{Uploading the Program}

After writing the program, connect the XIAO main control board to the
computer using a data cable, as shown below:
\includegraphics{index_files/mediabag/1615972066074-7b4972.png-averageHue=-dddcdc-height=1073-id=m}
Once connected, click on the ``Upload'' button to upload the program to
the hardware. When the debugging area displays ``Upload Successful'',
check if the OLED display screen has shown a circular pattern.
\includegraphics{index_files/mediabag/1616923633490-077b6b.jpeg-averageHue=-b5b2a9-height=420-id=C}
\#\# 1.6.4 Extended Exercise Try drawing some more complex patterns.

\bookmarksetup{startatroot}

\hypertarget{project-practice-for-beginners---introduction-to-prototype-design}{%
\chapter{Project Practice for Beginners - Introduction to Prototype
Design}\label{project-practice-for-beginners---introduction-to-prototype-design}}

This unit will delve into project practice with a few classic projects
as case studies. We will learn how to create a quick verification
prototype starting from an idea. Instead of analyzing code line by line
as we've done previously, we will only explain critical steps in this
unit. The focus will be more on the practical application of code.
Arduino's libraries and example programs are abundant, as are community
resources.

When working on a project, we should be adept at finding these
resources, referring to example programs, and adjusting the code
according to our needs to achieve the desired effects more quickly.
Furthermore, this unit will begin to cover how to design appearances
based on the effects achieved by the program. We will start by
repurposing items around us, combining these items with electronic
hardware to quickly form prototype works.

\bookmarksetup{startatroot}

\hypertarget{intermediate-project-practicecomplex-projects}{%
\chapter{Intermediate Project Practice---Complex
Projects}\label{intermediate-project-practicecomplex-projects}}

In this unit, we will delve into more intricate and comprehensive
projects, striving towards mature works in terms of program
implementation and design of appearance structure. These include
miniaturized smart homes, wearable electronic devices, interactive
electronic instruments, Wi-Fi connectivity, and applications enabled by
XIAO ESP32C3 or telemetry and command via the MQTT protocol. We will
provide the laser-cut design blueprints for the first three cases for
your reference. Of course, you're not limited to these examples; you
could use other, more accessible materials, such as corrugated cardboard
or cardstock, for crafting. Feel free to unleash your creativity and
design the work you wish to present!

\bookmarksetup{startatroot}

\hypertarget{project-practice-advanced---tinyml-applications}{%
\chapter{Project Practice Advanced - TinyML
Applications}\label{project-practice-advanced---tinyml-applications}}

Among the XIAO series products, the Seeed Studio XIAO nRF52840 Sense has
Bluetooth 5.0 wireless connectivity, low power consumption, and onboard
6-axis IMU and PDM microphone sensors. Besides, the XIAO ESP32S3 Sense
further integrates PSRAM, a camera, a digital microphone, and SD card
support.

\begin{quote}
Those characteristics make those devices powerful tools for TinyML (Tiny
Machine Learning) projects.
\end{quote}

TinyML solves problems in a completely different way from traditional
programming methods. This chapter will introduce you to this
cutting-edge field by walking through the entire TinyML workflow, from
data collection, pre-processing, model definition, training, testing,
and deployment to allow actual inference on the physical world.

\bookmarksetup{startatroot}

\hypertarget{esp32s3-setup}{%
\chapter*{ESP32S3 Setup}\label{esp32s3-setup}}
\addcontentsline{toc}{chapter}{ESP32S3 Setup}

\markboth{ESP32S3 Setup}{ESP32S3 Setup}

Setup the Seeed XIAO ESP32S3 Sense.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/_nOXij20mq1.jpg}

}

\caption{img}

\end{figure}

\hypertarget{introduction-1}{%
\section*{Introduction}\label{introduction-1}}
\addcontentsline{toc}{section}{Introduction}

\markright{Introduction}

Seeed Studio launched 2023 a new affordable development board, the
\href{https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html}{XIAO
ESP32S3 Sense}, which integrates a camera sensor, digital microphone,
and SD card support. Combining embedded ML computing power and
photography capability, this development board is a great tool to start
with TinyML (intelligent voice and vision AI).

\begin{figure}[H]

{\centering \includegraphics{images/imgs_esp32s3_setup/1.jpeg}

}

\caption{image.png}

\end{figure}

\textbf{XIAO ESP32S3 Sense Main Features}

\begin{itemize}
\tightlist
\item
  \textbf{Powerful MCU Board}: Incorporate the ESP32S3 32-bit,
  dual-core, Xtensa processor chip operating up to 240 MHz, mounted
  multiple development ports, Arduino / MicroPython supported
\item
  \textbf{Advanced Functionality}: Detachable OV2640 camera sensor for
  1600*1200 resolution, compatible with OV5640 camera sensor,
  integrating an additional digital microphone
\item
  \textbf{Elaborate Power Design}: Lithium battery charge management
  capability offer four power consumption model, which allows for deep
  sleep mode with power consumption as low as 14ŒºA
\item
  \textbf{Great Memory for more Possibilities}: Offer 8MB PSRAM and 8MB
  FLASH, supporting SD card slot for external 32GB FAT memory
\item
  \textbf{Outstanding RF performance}: Support 2.4GHz Wi-Fi and BLE dual
  wireless communication, support 100m+ remote communication when
  connected with U.FL antenna
\item
  \textbf{Thumb-sized Compact Design}: 21 x 17.5mm, adopting the classic
  form factor of XIAO, suitable for space-limited projects like wearable
  devices
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{images/imgs_esp32s3_setup/3.png}

}

\end{figure}

Below is the general board pinout:

\begin{figure}[H]

{\centering \includegraphics{images/imgs_esp32s3_setup/2.png}

}

\end{figure}

\begin{quote}
For more details, please refer to the Seeed Studio WiKi page:
https://wiki.seeedstudio.com/xiao\_esp32s3\_getting\_started/
\end{quote}

\hypertarget{installing-the-xiao-esp32s3-sense-on-arduino-ide}{%
\section*{Installing the XIAO ESP32S3 Sense on Arduino
IDE}\label{installing-the-xiao-esp32s3-sense-on-arduino-ide}}
\addcontentsline{toc}{section}{Installing the XIAO ESP32S3 Sense on
Arduino IDE}

\markright{Installing the XIAO ESP32S3 Sense on Arduino IDE}

On Arduino IDE, navigate to \textbf{File \textgreater{} Preferences},
and fill in the URL:

\href{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json}{\emph{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package\_esp32\_dev\_index.json}}

on the field ==\textgreater{} \textbf{Additional Boards Manager URLs}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_JkHMk.png}

}

\caption{Pasted Graphic.png}

\end{figure}

Next, open boards manager. Go to \textbf{Tools} \textgreater{}
\textbf{Board} \textgreater{} \textbf{Boards Manager\ldots{}} and enter
with \emph{esp32.} Select and install the most updated and stable
package (avoid \emph{alpha} versions) :

\begin{quote}
The current alpha versions (3.0) did not work correctly with the
XIAO---the 2.0.8 or 2.0.14 work fine.
\end{quote}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_2_Otw.png}

}

\caption{Pasted Graphic 2.png}

\end{figure}

On \textbf{Tools}, select the Board (\textbf{XIAO ESP32S3}):

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_4_srw.jpg}

}

\caption{Pasted Graphic 4.png}

\end{figure}

Last but not least, select the \textbf{Port} where the ESP32S3 is
connected.

That is it! The device should be OK. Let's do some tests.

\hypertarget{testing-the-board-with-blink}{%
\section*{Testing the board with
BLINK}\label{testing-the-board-with-blink}}
\addcontentsline{toc}{section}{Testing the board with BLINK}

\markright{Testing the board with BLINK}

The XIAO ESP32S3 Sense has a built-in LED that is connected to GPIO21.
So, you can run the blink sketch as it is (using the LED\_BUILTIN
Arduino constant) or by changing the Blink sketch accordingly:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define LED\_BUILT\_IN }\DecValTok{21}\PreprocessorTok{ }

\DataTypeTok{void}\NormalTok{ setup}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  pinMode}\OperatorTok{(}\NormalTok{LED\_BUILT\_IN}\OperatorTok{,}\NormalTok{ OUTPUT}\OperatorTok{);} \CommentTok{// Set the pin as output}
\OperatorTok{\}}

\CommentTok{// Remember that the pin works with inverted logic}
\CommentTok{// LOW to Turn on and HIGH to turn off}
\DataTypeTok{void}\NormalTok{ loop}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILT\_IN}\OperatorTok{,}\NormalTok{ LOW}\OperatorTok{);} \CommentTok{//Turn on}
\NormalTok{  delay }\OperatorTok{(}\DecValTok{1000}\OperatorTok{);} \CommentTok{//Wait 1 sec}
\NormalTok{  digitalWrite}\OperatorTok{(}\NormalTok{LED\_BUILT\_IN}\OperatorTok{,}\NormalTok{ HIGH}\OperatorTok{);} \CommentTok{//Turn off}
\NormalTok{  delay }\OperatorTok{(}\DecValTok{1000}\OperatorTok{);} \CommentTok{//Wait 1 sec}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Note that the pins work with inverted logic: LOW to Turn on and HIGH to
turn off
\end{quote}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/blink_Lg3KqJa6ln.png}

}

\caption{blink.png}

\end{figure}

\hypertarget{connecting-sense-module-expansion-board}{%
\section*{Connecting Sense module (Expansion
Board)}\label{connecting-sense-module-expansion-board}}
\addcontentsline{toc}{section}{Connecting Sense module (Expansion
Board)}

\markright{Connecting Sense module (Expansion Board)}

When purchased, the expansion board is separated from the main board,
but installing the expansion board is very simple. You need to align the
connector on the expansion board with the B2B connector on the XIAO
ESP32S3, press it hard, and when you hear a ``click,'' the installation
is complete.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/61.gif}

}

\caption{img}

\end{figure}

As commented in the introduction, the expansion board, or the ``sense''
part of the device, has a 1600x1200 OV2640 camera, an SD card slot, and
a digital microphone.

\hypertarget{microphone-test}{%
\section*{Microphone Test}\label{microphone-test}}
\addcontentsline{toc}{section}{Microphone Test}

\markright{Microphone Test}

Let's start with sound detection. Go to the
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense}{GitHub project} and
download the sketch:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Mic_Test/XiaoEsp32s3_Mic_Test}{XIAOEsp2s3\_Mic\_Test}
and run it on the Arduino IDE:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_9_g3j.jpg}

}

\caption{Pasted Graphic 9.png}

\end{figure}

When producing sound, you can verify it on the Serial Plotter.

\textbf{Save recorded sound (.wav audio files) to a microSD card.}

Now, the onboard SD Card reader can save .wav audio files. For that, we
need to habilitate the XIAO PSRAM.

\begin{quote}
ESP32-S3 has only a few hundred kilobytes of internal RAM on the MCU
chip. It can be insufficient for some purposes, so ESP32-S3 can use up
to 16 MB of external PSRAM (Psuedostatic RAM) connected in parallel with
the SPI flash chip. The external memory is incorporated in the memory
map and, with certain restrictions, is usable in the same way as
internal data RAM.
\end{quote}

For a start, Insert the SD Card on the XIAO as shown in the photo below
(the SD Card should be formatted to \textbf{FAT32}).

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_Z0TlaWDD8O.jpg}

}

\caption{image.png}

\end{figure}

\begin{itemize}
\tightlist
\item
  Download the sketch
  \href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Mic_Test/Wav_Record}{Wav\_Record},
  which you can find on GitHub.
\item
  To execute the code (Wav Record), it is necessary to use the PSRAM
  function of the ESP-32 chip, so turn it on before uploading.:
  \texttt{Tools\textgreater{}PSRAM:\ "OPI\ PSRAM‚Äù\textgreater{}OPI\ PSRAM}
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_10_VY.jpg}

}

\caption{Pasted Graphic 10.png}

\end{figure}

\begin{itemize}
\tightlist
\item
  Run the code Wav\_Record.ino
\item
  This program is executed only once after the user \textbf{turns on the
  serial monitor}, recording for 20 seconds and saving the recording
  file to a microSD card as ``arduino\_rec.wav''.
\item
  When the ``.'' is output every 1 second in the serial monitor, the
  program execution is finished, and you can play the recorded sound
  file with the help of a card reader.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_11_bB.png}

}

\caption{Pasted Graphic 11.png}

\end{figure}

The sound quality is excellent!

\begin{quote}
The explanation of how the code works is beyond the scope of this
tutorial, but you can find an excellent description on the
\href{https://wiki.seeedstudio.com/xiao_esp32s3_sense_mic\#save-recorded-sound-to-microsd-card}{wiki}
page.
\end{quote}

\hypertarget{testing-the-camera}{%
\section*{Testing the Camera}\label{testing-the-camera}}
\addcontentsline{toc}{section}{Testing the Camera}

\markright{Testing the Camera}

For testing the camera, you should download the folder
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/take_photos_command}{take\_photos\_command}
from GitHub. The folder contains the sketch (.ino) and two .h files with
camera details.

\begin{itemize}
\tightlist
\item
  Run the code: take\_photos\_command.ino. Open the Serial Monitor and
  send the command ``capture'' to capture and save the image on the SD
  Card:
\end{itemize}

\begin{quote}
Verify that {[}Both NL \& CR{]} is selected on Serial Monitor.
\end{quote}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/capture_8aHAA2OzDt.png}

}

\caption{capture.png}

\end{figure}

Here is an example of a taken photo:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_vCiev0aEuH.jpg}

}

\caption{image.png}

\end{figure}

\hypertarget{testing-wifi}{%
\section*{Testing WiFi}\label{testing-wifi}}
\addcontentsline{toc}{section}{Testing WiFi}

\markright{Testing WiFi}

One of the differentiators of the XIAO ESP32S3 is its WiFi capability.
So, let's test its radio, scanning the wifi networks around it. You can
do it by running one of the code examples on the board.

Go to Arduino IDE Examples and look for \textbf{WiFI ==\textgreater{}
WiFIScan}

On the Serial monitor, you should see the wifi networks (SSIDs and
RSSIs) in the range of your device. Here is what I got on the lab:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_14_mb.png}

}

\caption{Pasted Graphic 14.png}

\end{figure}

\textbf{Simple WiFi Server (Turning LED ON/OFF)}

Let's test the device's capability to behave as a WiFi Server. We will
host a simple page on the device that sends commands to turn the XIAO
built-in LED ON and OFF.

Like before, go to GitHub to download the folder with the sketch:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/SimpleWiFiServer}{SimpleWiFiServer}.

Before running the sketch, you should enter your network credentials:

\begin{verbatim}
const char* ssid     = "Your credentials here";
const char* password = "Your credentials here";
\end{verbatim}

You can monitor how your server is working with the Serial Monitor.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_l0yhot2BP2.png}

}

\caption{image.png}

\end{figure}

Take the IP address and enter it on your browser:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_18_Ti.png}

}

\caption{Pasted Graphic 18.png}

\end{figure}

You will see a page with links that can turn ON and OFF the built-in LED
of your XIAO.

\textbf{Streaming video to Web}

Now that you know that you can send commands from the webpage to your
device, let's do the reverse. Let's take the image captured by the
camera and stream it to a webpage:

Download from GitHub the
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Streeming_Video}{folder}
that contains the code: XIAO-ESP32S3-Streeming\_Video.ino.

\begin{quote}
Remember that the folder contains not only the.ino file, but also a
couple of.h files, necessary to handle the camera.
\end{quote}

Enter your credentials and run the sketch. On the Serial monitor, you
can find the page address to enter in your browser:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_21_s4.png}

}

\caption{Pasted Graphic 21.png}

\end{figure}

Open the page on your browser (wait a few seconds to start the
streaming). That's it.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_19_xs.png}

}

\caption{Pasted Graphic 19.png}

\end{figure}

Streamlining what your camera is ``seen'' can be important when you
position it to capture a dataset for an ML project (for example, using
the code ``take\_phots\_commands.ino''.

Of course, we can do both things simultaneously, show what the camera is
seeing on the page, and send a command to capture and save the image on
the SD card. For that, you can use the code Camera\_HTTP\_Server\_STA
which
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Camera_HTTP_Server_STA}{folder}
can be downloaded from GitHub.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_29_Tq.png}

}

\caption{Pasted Graphic 29.png}

\end{figure}

The program will do the following tasks:

\begin{itemize}
\tightlist
\item
  Set the camera to JPEG output mode.
\item
  Create a web page (for example ==\textgreater{}
  http://192.168.4.119//). The correct address will be displayed on the
  Serial Monitor.
\item
  If server.on (``/capture'', HTTP\_GET, serverCapture), the program
  takes a photo and sends it to the Web.
\item
  It is possible to rotate the image on webPage using the button
  {[}ROTATE{]}
\item
  The command {[}CAPTURE{]} only will preview the image on the webpage,
  showing its size on Serial Monitor
\item
  The {[}SAVE{]} command will save an image on the SD Card, also showing
  the image on the web.
\item
  Saved images will follow a sequential naming (image1.jpg, image2.jpg.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_32_Xj.png}

}

\caption{Pasted Graphic 32.png}

\end{figure}

\begin{quote}
This program can be used for an image dataset capture with an Image
Classification project.
\end{quote}

Inspect the code; it will be easier to understand how the camera works.
This code was developed based on the great Rui Santos Tutorial:
\href{https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/}{ESP32-CAM
Take Photo and Display in Web Server}, which I invite all of you to
visit.

\hypertarget{collecting-dataset-with-the-esp-camera-web-server}{%
\subsection*{Collecting Dataset with the ESP Camera Web
Server}\label{collecting-dataset-with-the-esp-camera-web-server}}
\addcontentsline{toc}{subsection}{Collecting Dataset with the ESP Camera
Web Server}

The ESP32 Library has a general aplictation to setup and test the
camera, that can be also used to collect image datasets. Alternatively,
lets use here the Arduino IDE 2.x.

Open the Arduino IDE and select the \texttt{XIAO\_ESP32S3} board (and
the port where it is connected). On
\texttt{File\ \textgreater{}\ Examples\ \textgreater{}\ ESP32\ \textgreater{}\ Camera},
select \texttt{CameraWebServer}. On the BOARDS MANAGER panel, confirm
that you have installed the latest ``stable'' package.

You also should comment on all cameras' models, except the XIAO model
pins: \#define CAMERA\_MODEL\_XIAO\_ESP32S3 // Has PSRAM and on Tools,
enable the PSRAM. Enter your wifi credentials and upload the code to the
device:

\begin{figure}[H]

{\centering \includegraphics{images/imgs_esp32s3_setup/ide-1.jpg}

}

\end{figure}

If the code is executed corretctelly, you should see the address on the
Serial Monitor:

\begin{figure}[H]

{\centering \includegraphics{images/imgs_esp32s3_setup/ide-2.png}

}

\end{figure}

Copy the address on your browser and wait for the page to be uploaded.
Select the camera resolution (for example, QVGA) and select
\texttt{{[}START\ STREAM{]}}. Wait for a few seconds/minutes, depending
on your connection. You can change and test several of the camera setup
and also save an image on your computer's download area using the
\texttt{{[}Save{]}} button.

\begin{figure}[H]

{\centering \includegraphics{Users/marcelo_rovai/Dropbox/2024/40_ICTP/images/imgs_esp32s3_setup/cam_save_imgs.jpg}

}

\end{figure}

\hypertarget{conclusion}{%
\section*{Conclusion}\label{conclusion}}
\addcontentsline{toc}{section}{Conclusion}

\markright{Conclusion}

The XIAO ESP32S3 Sense is a very flexible, not expensive, and
easy-to-program device. It can be used on TinyML projects. Also we saw
that memory is not an issue; the device can handle many post-processing
tasks, including communication.

On the GitHub repository, you will find the last version of the codes:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense}{XIAO-ESP32S3-Sense.}

\bookmarksetup{startatroot}

\hypertarget{tinyml-made-easy-image-classification}{%
\chapter*{4.4 TinyML Made Easy: Image
Classification}\label{tinyml-made-easy-image-classification}}
\addcontentsline{toc}{chapter}{4.4 TinyML Made Easy: Image
Classification}

\markboth{4.4 TinyML Made Easy: Image Classification}{4.4 TinyML Made
Easy: Image Classification}

Exploring Machine Learning on the tremendous new tiny device of the
Seeed XIAO family, the ESP32S3 Sense.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/_nOXij20mq1.jpg}

}

\caption{img}

\end{figure}

\hypertarget{things-used-in-this-project}{%
\section*{4.4.1 Things used in this
project}\label{things-used-in-this-project}}
\addcontentsline{toc}{section}{4.4.1 Things used in this project}

\markright{4.4.1 Things used in this project}

\hypertarget{hardware-components}{%
\subsection*{4.4.1.1 Hardware components}\label{hardware-components}}
\addcontentsline{toc}{subsection}{4.4.1.1 Hardware components}

\includegraphics{index_files/mediabag/1698372025691-4acf4d.5}\href{https://www.hackster.io/seeed/products/seeed-xiao-esp32s3-sense?ref=project-cb42ae}{Seeed
Studio Seeed XIAO ESP32S3 Sense} x 1

\hypertarget{software-apps-and-online-services}{%
\subsection*{4.4.2 Software apps and online
services}\label{software-apps-and-online-services}}
\addcontentsline{toc}{subsection}{4.4.2 Software apps and online
services}

\begin{itemize}
\tightlist
\item
  \includegraphics{index_files/mediabag/1669875695345-b20a52.png-averageHue=-f3f4f1-clientId=u413b5b}
  \href{https://www.hackster.io/arduino/products/arduino-ide?ref=project-958fd2}{Arduino
  IDE}
\item
  \includegraphics{index_files/mediabag/1669875769259-c9ab4b.png-averageHue=-cfe688-clientId=ud4d226}
  \href{https://www.hackster.io/EdgeImpulse/products/edge-impulse-studio?ref=project-958fd2}{Edge
  Impulse Studio}
\end{itemize}

\hypertarget{introduction-2}{%
\section*{4.4.2 Introduction}\label{introduction-2}}
\addcontentsline{toc}{section}{4.4.2 Introduction}

\markright{4.4.2 Introduction}

More and more, we are facing an artificial intelligence (AI) revolution
where, as stated by Gartner, \textbf{Edge AI} has a very high impact
potential, and \textbf{it is for now}!

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_EZKT6sirt5.jpg}

}

\caption{image.png}

\end{figure}

In the ``bull-eye'' of emerging technologies, radar is the \emph{Edge
Computer Vision}, and when we talk about Machine Learning (ML) applied
to vision, the first thing that comes to mind is \textbf{Image
Classification}, a kind of ML ``Hello World''!

Seeed Studio released a new affordable development board, the
\href{https://www.seeedstudio.com/XIAO-ESP32S3-Sense-p-5639.html}{XIAO
ESP32S3 Sense}, which integrates a camera sensor, digital microphone,
and SD card support. Combining embedded ML computing power and
photography capability, this development board is a great tool to start
with TinyML (intelligent voice and vision AI).

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_kRGbYBWevi.jpg}

}

\caption{image.png}

\end{figure}

\textbf{XIAO ESP32S3 Sense Main Features}

\begin{itemize}
\tightlist
\item
  \textbf{Powerful MCU Board}: Incorporate the ESP32S3 32-bit,
  dual-core, Xtensa processor chip operating up to 240 MHz, mounted
  multiple development ports, Arduino / MicroPython supported
\item
  \textbf{Advanced Functionality}: Detachable OV2640 camera sensor for
  1600*1200 resolution, compatible with OV5640 camera sensor,
  integrating an additional digital microphone
\item
  \textbf{Elaborate Power Design}: Lithium battery charge management
  capability offer four power consumption model, which allows for deep
  sleep mode with power consumption as low as 14ŒºA
\item
  \textbf{Great Memory for more Possibilities}: Offer 8MB PSRAM and 8MB
  FLASH, supporting SD card slot for external 32GB FAT memory
\item
  \textbf{Outstanding RF performance}: Support 2.4GHz Wi-Fi and BLE dual
  wireless communication, support 100m+ remote communication when
  connected with U.FL antenna
\item
  \textbf{Thumb-sized Compact Design}: 21 x 17.5mm, adopting the classic
  form factor of XIAO, suitable for space-limited projects like wearable
  devices
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/mty4odg1ntkynti4ntey.png}

}

\caption{MTY4ODg1NTkyNTI4NTEyMg\_561868\_B55w78PjvcK7SUlF\_1679553921.png}

\end{figure}

Below is the general board pinout:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/xiao_esp32c3_sense_p.png}

}

\caption{XIAO\_ESP32C3\_Sense\_pin-out.png}

\end{figure}

\begin{quote}
For more details, please refer to Seeed Studio WiKi page:
https://wiki.seeedstudio.com/xiao\_esp32s3\_getting\_started/
\end{quote}

\hypertarget{installing-the-xiao-esp32s3-sense-on-arduino-ide-1}{%
\section*{4.4.3 Installing the XIAO ESP32S3 Sense on Arduino
IDE}\label{installing-the-xiao-esp32s3-sense-on-arduino-ide-1}}
\addcontentsline{toc}{section}{4.4.3 Installing the XIAO ESP32S3 Sense
on Arduino IDE}

\markright{4.4.3 Installing the XIAO ESP32S3 Sense on Arduino IDE}

On Arduino IDE, navigate to \textbf{File \textgreater{} Preferences},
and fill in the URL:

\href{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json}{\emph{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package\_esp32\_dev\_index.json}}

on the field ==\textgreater{} \textbf{Additional Boards Manager URLs}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_JkHMk.png}

}

\caption{Pasted Graphic.png}

\end{figure}

Next, open boards manager. Go to \textbf{Tools} \textgreater{}
\textbf{Board} \textgreater{} \textbf{Boards Manager\ldots{}} and enter
with \emph{esp32.} Select and install the most updated and stable
package (avoid \emph{alpha} versions) :

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_2_Otw.png}

}

\caption{Pasted Graphic 2.png}

\end{figure}

On \textbf{Tools}, select the Board (\textbf{XIAO ESP32S3}):

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_4_srw.jpg}

}

\caption{Pasted Graphic 4.png}

\end{figure}

Last but not least, select the \textbf{Port} where the ESP32S3 is
connected.

That is it! The device should be OK. Let's do some tests.

\hypertarget{testing-the-board-with-blink-1}{%
\section*{4.4.4 Testing the board with
BLINK}\label{testing-the-board-with-blink-1}}
\addcontentsline{toc}{section}{4.4.4 Testing the board with BLINK}

\markright{4.4.4 Testing the board with BLINK}

The XIAO ESP32S3 Sense has a built-in LED that is connected to GPIO21.
So, you can run the blink sketch as it (using the LED\_BUILTIN Arduino
constant) or by changing the Blink sketch accordantly:

\begin{verbatim}
#define LED_BUILT_IN 21 

void setup() {
  pinMode(LED_BUILT_IN, OUTPUT); // Set the pin as output
}

// Remember that the pin work with inverted logic
// LOW to Turn on and HIGH to turn off
void loop() {
  digitalWrite(LED_BUILT_IN, LOW); //Turn on
  delay (1000); //Wait 1 sec
  digitalWrite(LED_BUILT_IN, HIGH); //Turn off
  delay (1000); //Wait 1 sec
}
\end{verbatim}

\begin{quote}
Note that the pins work with inverted logic: LOW to Turn on and HIGH to
turn off
\end{quote}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/blink_Lg3KqJa6ln.png}

}

\caption{blink.png}

\end{figure}

\hypertarget{connecting-sense-module-expansion-board-1}{%
\section*{4.4.5 Connecting Sense module (Expansion
Board)}\label{connecting-sense-module-expansion-board-1}}
\addcontentsline{toc}{section}{4.4.5 Connecting Sense module (Expansion
Board)}

\markright{4.4.5 Connecting Sense module (Expansion Board)}

When purchased, the expansion board is separated from the main board,
but installing the expansion board is very simple. You need to align the
connector on the expansion board with the B2B connector on the XIAO
ESP32S3, press it hard, and when you hear a ``click,'' the installation
is complete.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/61.gif}

}

\caption{img}

\end{figure}

As commented in the introduction, the expansion board, or the ``sense''
part of the device, has a 1600x1200 OV2640 camera, an SD card slot, and
a digital microphone.

\hypertarget{microphone-test-1}{%
\section*{4.4.6 Microphone Test}\label{microphone-test-1}}
\addcontentsline{toc}{section}{4.4.6 Microphone Test}

\markright{4.4.6 Microphone Test}

Let's start with sound detection. Go to the
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense}{GitHub project} and
download the sketch:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Mic_Test/XiaoEsp32s3_Mic_Test}{XIAOEsp2s3\_Mic\_Test}
and run it on the Arduino IDE:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_9_g3j.jpg}

}

\caption{Pasted Graphic 9.png}

\end{figure}

When producing sound, you can verify it on the Serial Plotter.

\textbf{Save recorded sound (.wav audio files) to a microSD card.}

Let's now use the onboard SD Card reader to save .wav audio files. For
that, we need to habilitate the XIAO PSRAM.

\begin{quote}
ESP32-S3 has only a few hundred kilobytes of internal RAM on the MCU
chip. It can be insufficient for some purposes so that ESP32-S3 can use
up to 16 MB of external PSRAM (Psuedostatic RAM) connected in parallel
with the SPI flash chip. The external memory is incorporated in the
memory map and, with certain restrictions, is usable in the same way as
internal data RAM.
\end{quote}

For a start, Insert the SD Card on the XIAO as shown in the photo below
(the SD Card should be formatted to \textbf{FAT32}).

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_Z0TlaWDD8O.jpg}

}

\caption{image.png}

\end{figure}

\begin{itemize}
\tightlist
\item
  Download the sketch
  \href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Mic_Test/Wav_Record}{Wav\_Record},
  which you can find on GitHub.
\item
  To execute the code (Wav Record), it is necessary to use the PSRAM
  function of the ESP-32 chip, so turn it on before uploading.:
  Tools\textgreater PSRAM: ``OPI PSRAM''\textgreater OPI PSRAM
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_10_VY.jpg}

}

\caption{Pasted Graphic 10.png}

\end{figure}

\begin{itemize}
\tightlist
\item
  Run the code Wav\_Record.ino
\item
  This program is executed only once after the user \textbf{turns on the
  serial monitor}, recording for 20 seconds and saving the recording
  file to a microSD card as ``arduino\_rec.wav''.
\item
  When the ``.'' is output every 1 second in the serial monitor, the
  program execution is finished, and you can play the recorded sound
  file with the help of a card reader.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_11_bB.png}

}

\caption{Pasted Graphic 11.png}

\end{figure}

The sound quality is excellent!

\begin{quote}
The explanation of how the code works is beyond the scope of this
tutorial, but you can find an excellent description on the
\href{https://wiki.seeedstudio.com/xiao_esp32s3_sense_mic\#save-recorded-sound-to-microsd-card}{wiki}
page.
\end{quote}

\hypertarget{testing-the-camera-1}{%
\section*{4.4.7 Testing the Camera}\label{testing-the-camera-1}}
\addcontentsline{toc}{section}{4.4.7 Testing the Camera}

\markright{4.4.7 Testing the Camera}

For testing the camera, you should download the folder
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/take_photos_command}{take\_photos\_command}
from GitHub. The folder contains the sketch (.ino) and two .h files with
camera details.

\begin{itemize}
\tightlist
\item
  Run the code: take\_photos\_command.ino. Open the Serial Monitor and
  send the command ``capture'' to capture and save the image on the SD
  Card:
\end{itemize}

\begin{quote}
Verify that {[}Both NL \& CR{]} is selected on Serial Monitor.
\end{quote}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/capture_8aHAA2OzDt.png}

}

\caption{capture.png}

\end{figure}

Here is an example of a taken photo:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_vCiev0aEuH.jpg}

}

\caption{image.png}

\end{figure}

\hypertarget{testing-wifi-1}{%
\section*{4.4.8 Testing WiFi}\label{testing-wifi-1}}
\addcontentsline{toc}{section}{4.4.8 Testing WiFi}

\markright{4.4.8 Testing WiFi}

One of the differentiators of the XIAO ESP32S3 is its WiFi capability.
So, let's test its radio, scanning the wifi networks around it. You can
do it by running one of the code examples on the board.

Go to Arduino IDE Examples and look for \textbf{WiFI ==\textgreater{}
WiFIScan}

On the Serial monitor, you should see the wifi networks (SSIDs and
RSSIs) in the range of your device. Here is what I got on the lab:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_14_mb.png}

}

\caption{Pasted Graphic 14.png}

\end{figure}

\textbf{Simple WiFi Server (Turning LED ON/OFF)}

Let's test the device's capability to behave as a WiFi Server. We will
host a simple page on the device that sends commands to turn the XIAO
built-in LED ON and OFF.

Like before, go to GitHub to download the folder with the sketch:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/SimpleWiFiServer}{SimpleWiFiServer}.

Before running the sketch, you should enter your network credentials:

\begin{verbatim}
const char* ssid     = "Your credentials here";
const char* password = "Your credentials here";
\end{verbatim}

You can monitor how your server is working with the Serial Monitor.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_l0yhot2BP2.png}

}

\caption{image.png}

\end{figure}

Take the IP address and enter it on your browser:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_18_Ti.png}

}

\caption{Pasted Graphic 18.png}

\end{figure}

You will see a page with links that can turn ON and OFF the built-in LED
of your XIAO.

\textbf{Streaming video to Web}

Now that you know that you can send commands from the webpage to your
device, let's do the reverse. Let's take the image captured by the
camera and stream it to a webpage:

Download from GitHub the
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Streeming_Video}{folder}
that contains the code: XIAO-ESP32S3-Streeming\_Video.ino.

\begin{quote}
Remember that the folder contains not only the.ino file, but also a
couple of.h files, necessary to handle the camera.
\end{quote}

Enter your credentials and run the sketch. On the Serial monitor, you
can find the page address to enter in your browser:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_21_s4.png}

}

\caption{Pasted Graphic 21.png}

\end{figure}

Open the page on your browser (wait a few seconds to start the
streaming). That's it.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_19_xs.png}

}

\caption{Pasted Graphic 19.png}

\end{figure}

Streamlining what your camera is ``seen'' can be important when you
position it to capture a dataset for an ML project (for example, using
the code ``take\_phots\_commands.ino''.

Of course, we can do both things simultaneously, show what the camera is
seeing on the page, and send a command to capture and save the image on
the SD card. For that, you can use the code Camera\_HTTP\_Server\_STA
which
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/Camera_HTTP_Server_STA}{folder}
can be downloaded from GitHub.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_29_Tq.png}

}

\caption{Pasted Graphic 29.png}

\end{figure}

The program will do the following tasks:

\begin{itemize}
\tightlist
\item
  Set the camera to JPEG output mode.
\item
  Create a web page (for example ==\textgreater{}
  http://192.168.4.119//). The correct address will be displayed on the
  Serial Monitor.
\item
  If server.on (``/capture'', HTTP\_GET, serverCapture), the program
  takes a photo and sends it to the Web.
\item
  It is possible to rotate the image on webPage using the button
  {[}ROTATE{]}
\item
  The command {[}CAPTURE{]} only will preview the image on the webpage,
  showing its size on Serial Monitor
\item
  The {[}SAVE{]} command will save an image on the SD Card, also showing
  the image on the web.
\item
  Saved images will follow a sequential naming (image1.jpg, image2.jpg.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_32_Xj.png}

}

\caption{Pasted Graphic 32.png}

\end{figure}

\begin{quote}
This program can be used for an image dataset capture with an Image
Classification project.
\end{quote}

Inspect the code; it will be easier to understand how the camera works.
This code was developed based on the great Rui Santos Tutorial:
\href{https://randomnerdtutorials.com/esp32-cam-take-photo-display-web-server/}{ESP32-CAM
Take Photo and Display in Web Server}, which I invite all of you to
visit.

\hypertarget{fruits-versus-veggies---a-tinyml-image-classification-project}{%
\section*{4.4.9 Fruits versus Veggies - A TinyML Image Classification
project}\label{fruits-versus-veggies---a-tinyml-image-classification-project}}
\addcontentsline{toc}{section}{4.4.9 Fruits versus Veggies - A TinyML
Image Classification project}

\markright{4.4.9 Fruits versus Veggies - A TinyML Image Classification
project}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/vegetables-g3276e6aa.png}

}

\caption{img}

\end{figure}

Now that we have an embedded camera running, it is time to try image
classification. For comparative motive, we will replicate the same image
classification project developed to be used with an old ESP2-CAM:

\href{https://www.hackster.io/mjrobot/esp32-cam-tinyml-image-classification-fruits-vs-veggies-4ab970}{ESP32-CAM:
TinyML Image Classification - Fruits vs Veggies}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_60a57gQ8VS.jpg}

}

\caption{image.png}

\end{figure}

The whole idea of our project will be training a model and proceeding
with inference on the XIAO ESP32S3 Sense. For training, we should find
some data \textbf{(in fact, tons of data!}).

\emph{But first of all, we need a goal! What do we want to classify?}

With TinyML, a set of technics associated with machine learning
inference on embedded devices, we should limit the classification to
three or four categories due to limitations (mainly memory in this
situation). We will differentiate \textbf{apples} from \textbf{bananas}
and \textbf{potatoes} (you can try other categories)\textbf{.}

So, let's find a specific dataset that includes images from those
categories. Kaggle is a good start:

https://www.kaggle.com/kritikseth/fruit-and-vegetable-image-recognition

This dataset contains images of the following food items:

\begin{itemize}
\tightlist
\item
  \textbf{Fruits} - \emph{banana, apple}, pear, grapes, orange, kiwi,
  watermelon, pomegranate, pineapple, mango.
\item
  \textbf{Vegetables} - cucumber, carrot, capsicum, onion,
  \emph{potato,} lemon, tomato, radish, beetroot, cabbage, lettuce,
  spinach, soybean, cauliflower, bell pepper, chili pepper, turnip,
  corn, sweetcorn, sweet potato, paprika, jalepe√±o, ginger, garlic,
  peas, eggplant.
\end{itemize}

Each category is split into the \textbf{train} (100 images),
\textbf{test} (10 images), and \textbf{validation} (10 images).

\begin{itemize}
\tightlist
\item
  Download the dataset from the Kaggle website to your computer.
\end{itemize}

\begin{quote}
Optionally, you can add some fresh photos of bananas, apples, and
potatoes from your home kitchen, using, for example, the sketch
discussed in the last section.
\end{quote}

\hypertarget{training-the-model-with-edge-impulse-studio}{%
\section*{4.4.10 Training the model with Edge Impulse
Studio}\label{training-the-model-with-edge-impulse-studio}}
\addcontentsline{toc}{section}{4.4.10 Training the model with Edge
Impulse Studio}

\markright{4.4.10 Training the model with Edge Impulse Studio}

We will use the Edge Impulse Studio for training our model.
\href{https://www.edgeimpulse.com/}{Edge Impulse} is a leading
development platform for machine learning on edge devices.

Enter your account credentials (or create a free account) at Edge
Impulse. Next, create a new project:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_MDgkE355g3.png}

}

\caption{image.png}

\end{figure}

\textbf{Data Acquisition}

Next, on the UPLOAD DATA section, upload from your computer the files
from chosen categories:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_brdDCN6bc5.png}

}

\caption{img}

\end{figure}

You should now have your training dataset, split in three classes of
data:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_QyxusuY3DM.png}

}

\caption{img}

\end{figure}

\begin{quote}
You can upload extra data for further model testing or split the
training data. I will leave as it, to use most data possible.
\end{quote}

\textbf{Impulse Design}

An impulse takes raw data (in this case, images), extracts features
(resize pictures), and then uses a learning block to classify new data.

As mentioned, classifying images is the most common use of Deep
Learning, but much data should be used to accomplish this task. We have
around 90 images for each category. Is this number enough? Not at all!
We will need thousand of images to ``teach or model'' to differentiate
an apple from a banana. But, we can solve this issue by re-training a
previously trained model with thousands of images. We called this
technic ``Transfer Learning'' (TL).

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/tl_fuVIsKd7YV.png}

}

\caption{img}

\end{figure}

With TL, we can fine-tune a pre-trained image classification model on
our data, performing well even with relatively small image datasets (our
case).

So, starting from the raw images, we will resize them (96x96) pixels and
so, feeding them to our Transfer Learning block:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_QhTt0Av8u3.png}

}

\caption{img}

\end{figure}

\textbf{Pre-processing (Feature generation)}

Besides resizing the images, we should change them to Grayscale instead
to keep the actual RGB color depth. Doing that, each one of our data
samples will have dimension 9, 216 features (96x96x1). Keeping RGB, this
dimension would be three times bigger. Working with Grayscale helps to
reduce the amount of final memory needed for inference.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_eqGdUoXrMb.png}

}

\caption{img}

\end{figure}

Do not forget to ``Save parameters.'' This will generate the features to
be used in training.

\textbf{Training (Transfer Learning \& Data Augmentation)}

In 2007, Google introduced
\href{https://research.googleblog.com/2017/06/mobilenets-open-source-models-for.html}{MobileNetV1,}a
family of general-purpose computer vision neural networks designed with
mobile devices in mind to support classification, detection, and more.
MobileNets are small, low-latency, low-power models parameterized to
meet the resource constraints of various use cases.

Although the base MobileNet architecture is already tiny and has low
latency, many times, a specific use case or application may require the
model to be smaller and faster. MobileNet introduces a straightforward
parameter Œ± (alpha) called width multiplier to construct these smaller
and less computationally expensive models. The role of the width
multiplier Œ± is to thin a network uniformly at each layer.

Edge Impulse Studio has available MobileNet V1 (96x96 images) and V2
(96x96 and 160x160 images), with several different \textbf{Œ±} values
(from 0.05 to 1.0). For example, you will get the highest accuracy with
V2, 160x160 images, and Œ±=1.0. Of course, there is a trade-off. The
highest the accuracy, the more memory (around 1.3M RAM and 2.6M ROM)
will be needed to run the model and imply more latency.

The smaller footprint will be obtained at another extreme with
\textbf{MobileNet V1} and Œ±=0.10 (around 53.2K RAM and 101K ROM).

When we first published this project to be running on an ESP32-CAM, we
stayed at the lower side of possibilities which guaranteed the inference
with small latency but not with high accuracy. For this first pass, we
will keep this model design (\textbf{MobileNet V1} and Œ±=0.10).

Another important technic to be used with Deep Learning is \textbf{Data
Augmentation}. Data augmentation is a method that can help improve the
accuracy of machine learning models, creating additional artificial
data. A data augmentation system makes small, random changes to your
training data during the training process (such as flipping, cropping,
or rotating the images).

Under the rood, here you can see how Edge Impulse implements a data
Augmentation policy on your data:

\begin{verbatim}
# Implements the data augmentation policy
def augment_image(image, label):
    # Flips the image randomly
    image = tf.image.random_flip_left_right(image)

    # Increase the image size, then randomly crop it down to
    # the original dimensions
    resize_factor = random.uniform(1, 1.2)
    new_height = math.floor(resize_factor * INPUT_SHAPE[0])
    new_width = math.floor(resize_factor * INPUT_SHAPE[1])
    image = tf.image.resize_with_crop_or_pad(image, new_height, new_width)
    image = tf.image.random_crop(image, size=INPUT_SHAPE)

    # Vary the brightness of the image
    image = tf.image.random_brightness(image, max_delta=0.2)

    return image, label
\end{verbatim}

Exposure to these variations during training can help prevent your model
from taking shortcuts by ``memorizing'' superficial clues in your
training data, meaning it may better reflect the deep underlying
patterns in your dataset.

The final layer of our model will have 16 neurons with a 10\% of dropout
for overfitting prevention. Here is the Training output:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_iqCv79Lhga.png}

}

\caption{img}

\end{figure}

The result is not great. The model reached around 77\% of accuracy, but
the amount of RAM expected to be used during the inference is relatively
small (around 60 KBytes), which is very good.

\textbf{Deployment}

The trained model will be deployed as a.zip Arduino library:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_QqiDK41Uyp.png}

}

\caption{img}

\end{figure}

Open your Arduino IDE, and under \textbf{Sketch,} go to \textbf{Include
Library} and \textbf{add.ZIP Library.} Select the file you download from
Edge Impulse Studio, and that's it!

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_BQwzaHFlzZ.png}

}

\caption{image.png}

\end{figure}

Under the \textbf{Examples} tab on Arduino IDE, you should find a sketch
code under your project name.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_Xglfrz0mwe.jpg}

}

\caption{image.png}

\end{figure}

Open the Static Buffer example:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_1ZSC9qmEuR.png}

}

\caption{image.png}

\end{figure}

You can see that the first line of code is exactly the calling of a
library with all the necessary stuff for running inference on your
device.

\begin{verbatim}
#include <XIAO-ESP32S3-CAM-Fruits-vs-Veggies_inferencing.h>
\end{verbatim}

Of course, this is a generic code (a ``template''), that only gets one
sample of raw data (stored on the variable: \emph{features = \{\}} and
run the classifier, doing the inference. The result is shown on Serial
Monitor.

We should get the sample (image) from the camera and pre-process it
(resizing to 96x96, converting to grayscale, and flatting it). This will
be the input tensor of our model. The output tensor will be a vector
with three values (labels), showing the probabilities of each one of the
classes.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_vrxwEjpaAl.png}

}

\caption{image.png}

\end{figure}

Returning to your project (Tab Image), copy one of the Raw Data Sample:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_J6oBO8SFpW.png}

}

\caption{image.png}

\end{figure}

9, 216 features will be copied to the clipboard. This is the input
tensor (a flattened image of 96x96x1), in this case, bananas. Past this
Input tensor on features{[}{]} = \{0xb2d77b, 0xb5d687, 0xd8e8c0,
0xeaecba, 0xc2cf67, \ldots\}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_YYAJaMDMSG.png}

}

\caption{image.png}

\end{figure}

Edge Impulse included the
\href{https://github.com/espressif/esp-nn}{library ESP NN} in its SDK,
which contains optimized NN (Neural Network) functions for various
Espressif chips, including the ESP32S3 (runing at Arduino IDE).

Now, when running the inference, you should get, as a result, the
highest score for ``banana''.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_35_3M.png}

}

\caption{Pasted Graphic 35.png}

\end{figure}

Great news! Our device handles an inference, discovering that the input
image is a banana. Also, note that the inference time was around 317ms,
resulting in a maximum of 3 fps if you tried to classify images from a
video. It is a better result than the ESP32 CAM (525ms of latency).

Now, we should incorporate the camera and classify images in real-time.

Go to the Arduino IDE Examples and download from your project the sketch
esp32\_camera:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_hjX5k8gTl8.jpg}

}

\caption{image.png}

\end{figure}

You should change lines 32 to 75, which define the camera model and
pins, using the data related to our model. Copy and paste the below
lines, replacing the lines 32-75:

\begin{verbatim}
#define PWDN_GPIO_NUM     -1 
#define RESET_GPIO_NUM    -1 
#define XCLK_GPIO_NUM     10 
#define SIOD_GPIO_NUM     40 
#define SIOC_GPIO_NUM     39
#define Y9_GPIO_NUM       48 
#define Y8_GPIO_NUM       11 
#define Y7_GPIO_NUM       12 
#define Y6_GPIO_NUM       14 
#define Y5_GPIO_NUM       16 
#define Y4_GPIO_NUM       18 
#define Y3_GPIO_NUM       17 
#define Y2_GPIO_NUM       15 
#define VSYNC_GPIO_NUM    38 
#define HREF_GPIO_NUM     47 
#define PCLK_GPIO_NUM     13
\end{verbatim}

Here you can see the resulting code:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_4VmERAOAfF.png}

}

\caption{image.png}

\end{figure}

The modified sketch can be downloaded from GitHub:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense/tree/main/xiao_esp32s3_camera}{xiao\_esp32s3\_camera}.

\begin{quote}
Note that you can optionally keep the pins as a.h file as we did on
previous sections.
\end{quote}

Upload the code to your XIAO ESP32S3 Sense, and you should be OK to
start classifying your fruits and vegetables! You can check the result
on Serial Monitor.

\hypertarget{testing-the-model-inference}{%
\section*{4.4.11 Testing the Model
(Inference)}\label{testing-the-model-inference}}
\addcontentsline{toc}{section}{4.4.11 Testing the Model (Inference)}

\markright{4.4.11 Testing the Model (Inference)}

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/inferencia_FM2hfD6ET.jpg}

}

\caption{inferencia.jpg}

\end{figure}

Getting a photo with the camera, the classification result will appear
on the Serial Monitor:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/pasted_graphic_40_6R.png}

}

\caption{Pasted Graphic 40.png}

\end{figure}

Other tests:

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/inferencia2_eGWjtNny.png}

}

\caption{inferencia2.png}

\end{figure}

\hypertarget{testing-with-a-bigger-model}{%
\section*{4.4.12 Testing with a bigger
model}\label{testing-with-a-bigger-model}}
\addcontentsline{toc}{section}{4.4.12 Testing with a bigger model}

\markright{4.4.12 Testing with a bigger model}

Now, let's go to the other side of the model size. Let's select a
MobilinetV2 96x96 0.35, having as input RGB images.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_wUPCEECR3t.jpg}

}

\caption{image.png}

\end{figure}

Even with a bigger model, the accuracy is not good, and worst, the
amount of memory necessary to run the model increases five times, with
latency increasing seven times (note that the performance here is
estimated with a smaller device, the ESP-EYE. So, the real inference
with the ESP32S3 should be better).

\begin{quote}
To make our model better, we will probably need more images to be
trained.
\end{quote}

Even though our model did not improve in terms of accuracy, let's test
whether the XIAO can handle such a bigger model. We will do a simple
inference test with the Static Buffer sketch.

Let's redeploy the model. If the EON Compiler is enabled when you
generate the library, the total memory needed for inference should be
reduced, but it has no influence on accuracy.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_Ne6NKwD297.jpg}

}

\caption{image.png}

\end{figure}

Doing an inference with MobilinetV2 96x96 0.35, having as input RGB
images, the latency was of 219ms, what it is great for such bigger
model.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/espnn-infe1_c5bolsFL.jpg}

}

\caption{ESPnn-infe1.png}

\end{figure}

In our tests, this option works with MobileNet V2 but not V1. So, I
trained the model again, using the smallest version of MobileNet V2,
with an alpha of 0.05. Interesting that the resultin accuraccy was
higher.

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_lwYLKM696A.jpg}

}

\caption{image.png}

\end{figure}

\begin{quote}
Note that the estimated latency for an Arduino Portenta (ou Nicla),
running with a clock of 480MHz is 45ms.
\end{quote}

Deploying the model, I got an inference of only 135ms, remembering that
the XIAO run with half of the clock used by the Portenta/Nicla (240MHz):

\begin{figure}[H]

{\centering \includegraphics{index_files/mediabag/image_dAfOl9Tguz.png}

}

\caption{image.png}

\end{figure}

\hypertarget{conclusion-1}{%
\section*{4.4.13 Conclusion}\label{conclusion-1}}
\addcontentsline{toc}{section}{4.4.13 Conclusion}

\markright{4.4.13 Conclusion}

The XIAO ESP32S3 Sense is a very flexible, not expensive, and
easy-to-program device. The project proves the potential of TinyML.
Memory is not an issue; the device can handle many post-processing
tasks, including communication.

On the GitHub repository, you will find the last version of the codes:
\href{https://github.com/Mjrovai/XIAO-ESP32S3-Sense}{XIAO-ESP32S3-Sense.}

\bookmarksetup{startatroot}

\hypertarget{creative-experiments}{%
\chapter{Creative Experiments}\label{creative-experiments}}

Since its launch, the Seeed Studio XIAO series has been widely acclaimed
for its compact size, powerful performance, and versatile product range.
The maker community has produced a large number of projects created with
XIAO. Due to space constraints, we have selected some outstanding
projects made with XIAO by our makers. These projects fully demonstrate
the powerful functions and wide applications of XIAO. Let us follow the
makers' steps, stimulate creativity, and explore the endless
possibilities of XIAO. We hope you can draw inspiration from these
projects, use your imagination, and explore new territories with XIAO.

\bookmarksetup{startatroot}

\hypertarget{references}{%
\chapter*{References}\label{references}}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\hypertarget{to-learn-more}{%
\section*{To learn more:}\label{to-learn-more}}
\addcontentsline{toc}{section}{To learn more:}

\markright{To learn more:}

\hypertarget{online-courses}{%
\subsection*{Online Courses}\label{online-courses}}
\addcontentsline{toc}{subsection}{Online Courses}

\begin{itemize}
\tightlist
\item
  \href{https://sites.google.com/g.harvard.edu/tinyml/home}{Harvard
  School of Engineering and Applied Sciences - CS249r: Tiny Machine
  Learning}
\item
  \href{https://www.edx.org/professional-certificate/harvardx-tiny-machine-learning}{Professional
  Certificate in Tiny Machine Learning (TinyML) -- edX/Harvard}
\item
  \href{https://www.coursera.org/learn/introduction-to-embedded-machine-learning}{Introduction
  to Embedded Machine Learning - Coursera/Edge Impulse}
\item
  \href{https://www.coursera.org/learn/computer-vision-with-embedded-machine-learning}{Computer
  Vision with Embedded Machine Learning - Coursera/Edge Impulse}
\item
  \href{https://github.com/Mjrovai/UNIFEI-IESTI01-TinyML-2023.1}{UNIFEI-IESTI01
  TinyML: ``Machine Learning for Embedding Devices''}
\end{itemize}

\hypertarget{books}{%
\subsection*{Books}\label{books}}
\addcontentsline{toc}{subsection}{Books}

\begin{itemize}
\tightlist
\item
  \href{https://wesmckinney.com/book/}{``Python for Data Analysis by Wes
  McKinney''}
\item
  \href{https://www.manning.com/books/deep-learning-with-python}{``Deep
  Learning with Python'' by Fran√ßois Chollet} -
  \href{https://github.com/fchollet/deep-learning-with-python-notebooks}{GitHub
  Notebooks}
\item
  \href{https://www.oreilly.com/library/view/tinyml/9781492052036/}{``TinyML''
  by Pete Warden, Daniel Situnayake}
\item
  \href{https://github.com/PacktPublishing/TinyML-Cookbook}{``TinyML
  Cookbook'' by Gian Marco Iodice}
\item
  \href{https://github.com/ajaymache/machine-learning-yearning/blob/master/full\%20book/machine-learning-yearning.pdf}{``Technical
  Strategy for AI Engineers, In the Era of Deep Learning'' by Andrew Ng}
\item
  \href{https://www.oreilly.com/library/view/ai-at-the/9781098120191/}{``AI
  at the Edge'' book by Daniel Situnayake, Jenny Plunkett}
\item
  \href{https://harvard-edge.github.io/cs249r_book/}{``MACHINE LEARNING
  SYSTEMS for TinyML'' Collaborative effort}
\end{itemize}

\hypertarget{projects-repository}{%
\subsection*{Projects Repository}\label{projects-repository}}
\addcontentsline{toc}{subsection}{Projects Repository}

\begin{itemize}
\tightlist
\item
  \href{https://docs.edgeimpulse.com/experts/}{Edge Impulse Expert
  Network}
\end{itemize}

\bookmarksetup{startatroot}

\hypertarget{about-the-authors}{%
\chapter*{About the authors}\label{about-the-authors}}
\addcontentsline{toc}{chapter}{About the authors}

\markboth{About the authors}{About the authors}

\textbf{Lei Feng} is the leader of the technical support group and
product curriculum at Seeed Studio. An experienced author in the fields
of open-source hardware and edge computing, he has published several
books in China, including ``GameGo Beginner Programming Course for
Arcade „ÄäÂÅöÊ∏∏ÊàèÔºåÁé©ÁºñÁ®ã------Èõ∂Âü∫Á°ÄÂºÄÂèëÂæÆËΩØ Arcade ÊéåÊú∫Ê∏∏Êàè„Äã,'' ``Grove
Beginner Kit For Arduino - Codecraft Graphical Programming Course
„ÄäArduino ÂõæÂΩ¢ÂåñÁºñÁ®ãËΩªÊùæÂ≠¶„Äã'', and the Chinese translation of ``IoT for
Beginners „ÄäÊ∑±ÂÖ•ÊµÖÂá∫ IoTÔºöÂÆåÊï¥È°πÁõÆÈÄöÂÖ≥ÂÆûÊàò„Äã'' with support from
Microsoft China.

Lei Feng has created numerous tutorials and open-source documentation in
Chinese and English with his team. His hands-on experience developing
IoT and edge computing projects gives him unique insights into
simplifying complex concepts for beginners. As an engaging writer and
patient teacher, Lei Feng is the ideal guide to make Arduino and TinyML
approachable for newcomers worldwide.

\emph{LinkedIn profile:}
\href{https://www.linkedin.com/in/leon-feng-a029bb1/}{\emph{https://www.linkedin.com/in/leon-feng-a029bb1/}}

\textbf{Marcelo Rovai} is a recognized figure in engineering and
technology education, holding the title of Professor Honoris Causa from
the Federal University of Itajub√°, Brazil. His educational background
includes an Engineering degree from UNIFEI and an advanced
specialization from the Polytechnic School of S√£o Paulo University.
Further enhancing his expertise, he earned an MBA from IBMEC (INSPER)
and a Master's in Data Science from the Universidad del Desarrollo in
Chile.

With a career spanning several high-profile technology companies such as
AVIBRAS Airspace, ATT, NCR, and IGT, where he served as Vice President
for Latin America, he brings a wealth of industry experience to his
academic endeavors. He is a prolific writer on electronics-related
topics and shares his knowledge through open platforms like Hackster.io.

In addition to his professional pursuits, he is dedicated to educational
outreach, serving as a volunteer professor at UNIFEI and engaging with
the TinyML4D group as a Co-Chair, promoting TinyML education in
developing countries. His work underscores a commitment to leveraging
technology for societal advancement.

\emph{LinkedIn profile:}
\href{https://www.linkedin.com/in/marcelo-jose-rovai-brazil-chile/}{\emph{https://www.linkedin.com/in/marcelo-jose-rovai-brazil-chile/}}

\emph{Twitter handle:} \emph{@mjrovai}

\emph{Author public speaking samples (YouTube, etc.):}
\href{https://www.youtube.com/watch?v=KeXlAazzgKw}{\emph{https://www.youtube.com/watch?v=KeXlAazzgKw}}



\end{document}
